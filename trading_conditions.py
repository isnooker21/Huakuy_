# -*- coding: utf-8 -*-
"""
Trading Conditions Module
‡πÇ‡∏°‡∏î‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
"""

import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
from calculations import Position, PercentageCalculator, MarketAnalysisCalculator
from market_analysis import MarketSessionAnalyzer, MultiTimeframeAnalyzer

logger = logging.getLogger(__name__)

@dataclass
class Signal:
    """‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î"""
    direction: str  # "BUY" ‡∏´‡∏£‡∏∑‡∏≠ "SELL"
    symbol: str
    strength: float  # ‡πÅ‡∏£‡∏á‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì (0-100)
    confidence: float  # ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à (0-100)
    timestamp: datetime
    price: float
    volume_suggestion: float = 0.01
    stop_loss: float = 0.0
    take_profit: float = 0.0
    comment: str = ""

@dataclass
class CandleData:
    """‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô"""
    open: float
    high: float
    low: float
    close: float
    volume: float
    timestamp: datetime
    symbol: str = "UNKNOWN"  # ‡πÄ‡∏û‡∏¥‡πà‡∏° symbol field
    
    @property
    def is_green(self) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î)"""
        return self.close > self.open
        
    @property
    def is_red(self) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÅ‡∏î‡∏á (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î)"""
        return self.close < self.open
        
    @property
    def body_size_percentage(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå"""
        if self.open == 0:
            return 0.0
        return abs((self.close - self.open) / self.open) * 100
        
    @property
    def range_percentage(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ä‡πà‡∏ß‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå"""
        if self.low == 0:
            return 0.0
        return ((self.high - self.low) / self.low) * 100

class CandleAnalyzer:
    """‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô"""
    
    def __init__(self, min_strength_percentage: float = 20.0):
        """
        Args:
            min_strength_percentage: ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏Ç‡∏≠‡∏á‡πÅ‡∏£‡∏á‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå (‡∏•‡∏î‡∏à‡∏≤‡∏Å 50% ‡πÄ‡∏õ‡πá‡∏ô 20%)
        """
        self.min_strength_percentage = min_strength_percentage
        
    def analyze_candle_strength(self, candle: CandleData, volume_avg: float = 0) -> Dict[str, Any]:
        """
        ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏£‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô
        
        Args:
            candle: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô
            volume_avg: Volume ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
            
        Returns:
            Dict: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏£‡∏á
        """
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏£‡∏á‡∏à‡∏≤‡∏Å‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô
        body_strength = candle.body_size_percentage
        
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏£‡∏á‡∏à‡∏≤‡∏Å Volume
        volume_strength = 0.0
        if volume_avg > 0:
            volume_ratio = candle.volume / volume_avg
            volume_strength = min(100, volume_ratio * 50)  # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô 0-100
            
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏£‡∏á‡∏à‡∏≤‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤
        range_strength = min(100, candle.range_percentage * 10)
        
        # ‡∏£‡∏ß‡∏°‡πÅ‡∏£‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        total_strength = (body_strength * 0.4 + volume_strength * 0.4 + range_strength * 0.2)
        
        return {
            'body_strength': body_strength,
            'volume_strength': volume_strength,
            'range_strength': range_strength,
            'total_strength': total_strength,
            'is_strong': total_strength >= self.min_strength_percentage,
            'direction': self._determine_smart_direction(candle, total_strength)  # HYBRID: Trend + Counter-trend
        }
    
    def _determine_smart_direction(self, candle: CandleData, strength: float) -> str:
        """üéØ HYBRID SIGNAL: Trend + Counter-trend Smart Direction"""
        try:
            # üìä ‡∏ï‡∏±‡∏ß‡∏ä‡∏µ‡πâ‡∏ß‡∏±‡∏î Trend
            is_green = candle.is_green
            body_size = candle.body_size_percentage
            range_size = candle.range_percentage
            
            # üöÄ HYBRID LOGIC
            if strength > 70:  # ‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å
                if body_size > 60 and range_size > 5:
                    # Trend Following ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å
                    return 'BUY' if is_green else 'SELL'
                else:
                    # Counter-trend ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏£‡∏á‡∏°‡∏≤‡∏Å‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ momentum
                    return 'SELL' if is_green else 'BUY'
            elif strength > 40:  # ‡πÅ‡∏£‡∏á‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
                # Counter-trend ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å (‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡πÄ‡∏î‡∏¥‡∏°)
                return 'SELL' if is_green else 'BUY'
            else:  # ‡πÅ‡∏£‡∏á‡∏ô‡πâ‡∏≠‡∏¢
                if body_size > 40:
                    # Trend Following ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö momentum ‡πÄ‡∏•‡πá‡∏Å‡πÜ
                    return 'BUY' if is_green else 'SELL'
                else:
                    # Counter-trend ‡∏õ‡∏Å‡∏ï‡∏¥
                    return 'SELL' if is_green else 'BUY'
                    
        except Exception as e:
            logger.error(f"Error determining direction: {e}")
            return 'SELL' if candle.is_green else 'BUY'  # Fallback to counter-trend
        
    def check_volume_filter(self, current_volume: float, volume_history: List[float], 
                           min_volume_percentage: float = 120.0) -> bool:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Volume Filter
        
        Args:
            current_volume: Volume ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            volume_history: ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ Volume
            min_volume_percentage: ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏Ç‡∏≠‡∏á Volume ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå
            
        Returns:
            bool: ‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå Volume ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        """
        if not volume_history:
            return True  # ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö
            
        avg_volume = sum(volume_history) / len(volume_history)
        if avg_volume == 0:
            return True
            
        volume_percentage = (current_volume / avg_volume) * 100
        return volume_percentage >= min_volume_percentage

class TradingConditions:
    """‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î"""
    
    def __init__(self):
        self.candle_analyzer = CandleAnalyzer()
        self.last_candle_time = None
        self.orders_per_candle = {}  # ‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô order ‡∏ï‡πà‡∏≠‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô
        self.previous_candle_close = None  # ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
        
        # ‡πÄ‡∏û‡∏¥‡πà‡∏° Market Analysis
        self.session_analyzer = MarketSessionAnalyzer()
        self.mtf_analyzer = None  # ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
        
    def check_entry_conditions(self, candle: CandleData, positions: List[Position], 
                             account_balance: float, volume_history: List[float] = None, 
                             symbol: str = None) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤ Order
        
        Args:
            candle: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            account_balance: ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ
            volume_history: ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥ Volume
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
        """
        result = {
            'can_enter': False,
            'signal': None,
            'reasons': []
        }
        
        # üöÄ Initialize Force Balance Mode (‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
        force_balance_mode = False
        
        logger.info(f"üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏ó‡∏£‡∏î - Symbol: {symbol}")
        logger.info(f"   Candle: O:{candle.open:.2f} H:{candle.high:.2f} L:{candle.low:.2f} C:{candle.close:.2f}")
        logger.info(f"   Volume: {candle.volume}, Balance: {account_balance:,.2f}")
        
        # üöÄ HIGH-FREQUENCY ENTRY: Smart Entry Control ‡πÅ‡∏ó‡∏ô One Order per Candle
        candle_time_key = candle.timestamp.strftime("%Y%m%d%H%M")
        minute_key = candle.timestamp.strftime("%Y%m%d%H%M")
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô orders ‡∏ï‡πà‡∏≠‡∏ô‡∏≤‡∏ó‡∏µ (‡πÅ‡∏ó‡∏ô per candle)
        orders_this_minute = self.orders_per_candle.get(minute_key, 0)
        
        # üß† Adaptive Entry Limits ‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
        volatility_factor = self._calculate_market_volatility(candle)
        max_entries_per_minute = self._get_adaptive_entry_limit(volatility_factor, len(positions))
        
        if orders_this_minute >= max_entries_per_minute:
            result['reasons'].append(f"Entry limit reached: {orders_this_minute}/{max_entries_per_minute} per minute")
            logger.info(f"‚ö†Ô∏è Entry limit: {orders_this_minute}/{max_entries_per_minute} entries this minute")
            return result
        
        logger.info(f"‚úÖ High-Frequency OK: {orders_this_minute}/{max_entries_per_minute} entries this minute")
            
        # 2. Market Session Analysis
        session_params = self.session_analyzer.adjust_trading_parameters({
            'base_strength_threshold': 20.0,
            'base_max_positions': 4,
            'base_lot_multiplier': 1.0
        })
        
        # 3. Multi-Timeframe Confirmation  
        # üéØ FIXED: Counter-trend logic - ‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏û‡∏á
        if candle.close > candle.open:  # ‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß = ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô
            direction = "SELL"  # ‡∏Ç‡∏≤‡∏¢‡∏ï‡∏≠‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á (‡∏Ç‡∏≤‡∏¢‡πÅ‡∏û‡∏á)
        else:  # ‡πÅ‡∏ó‡πà‡∏á‡πÅ‡∏î‡∏á = ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡∏á
            direction = "BUY"   # ‡∏ã‡∏∑‡πâ‡∏≠‡∏ï‡∏≠‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡πà‡∏≥ (‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å)
        
        # Initialize mtf_analyzer with actual symbol if not done
        if self.mtf_analyzer is None and symbol:
            from market_analysis import MultiTimeframeAnalyzer
            self.mtf_analyzer = MultiTimeframeAnalyzer(symbol)
        
        mtf_result = self.mtf_analyzer.get_multi_timeframe_confirmation(direction) if self.mtf_analyzer else {'decision': 'WEAK'}
        mtf_decision = mtf_result['decision']
        
        # 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏£‡∏á‡∏ï‡∏•‡∏≤‡∏î‡πÅ‡∏ö‡∏ö‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô
        volume_avg = sum(volume_history) / len(volume_history) if volume_history else 0
        strength_analysis = self.candle_analyzer.analyze_candle_strength(candle, volume_avg)
        
        logger.info(f"   Session: {session_params['current_session']} (Threshold: {session_params['entry_threshold']}%)")
        logger.info(f"   Multi-TF Score: {mtf_result['confidence_score']}/100 ({mtf_decision['confidence']})")
        logger.info(f"   ‡πÅ‡∏£‡∏á‡∏ï‡∏•‡∏≤‡∏î: {strength_analysis['total_strength']:.2f}%")
        logger.info(f"   ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á: {strength_analysis['direction']}")
        
        # ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏ó‡πà‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏¥‡∏î‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤
        flexible_conditions = self._check_flexible_entry_conditions(candle, positions)
        
        # ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏ó‡∏£‡∏î‡πÅ‡∏ö‡∏ö‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô
        can_enter_analysis = False
        entry_reason = ""
        
        if flexible_conditions['can_enter']:
            can_enter_analysis = True
            entry_reason = f"‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô - {flexible_conditions['reason']}"
            strength_analysis['direction'] = flexible_conditions['direction']
            strength_analysis['is_strong'] = True
            strength_analysis['total_strength'] = 30.0
        elif mtf_decision['action'] != 'WAIT':
            can_enter_analysis = True
            entry_reason = f"Multi-Timeframe ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô ({mtf_decision['confidence']}, Score: {mtf_result['confidence_score']})"
            strength_analysis['is_strong'] = True
            strength_analysis['total_strength'] = max(30.0, mtf_result['confidence_score'] / 2)
        elif strength_analysis['is_strong'] or strength_analysis['total_strength'] >= session_params['entry_threshold']:
            can_enter_analysis = True
            entry_reason = f"‡πÅ‡∏£‡∏á‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ ({strength_analysis['total_strength']:.2f}% >= {session_params['entry_threshold']}%)"
        else:
            # üöÄ UNLIMITED ENTRY: ‡∏ú‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ‡∏ï‡πà‡∏≠
            can_enter_analysis = True
            if session_params['current_session'] in ['OVERLAP_LONDON_NY', 'LONDON'] and strength_analysis['total_strength'] >= 10.0:
                entry_reason = f"Session ‡∏™‡∏π‡∏á + ‡πÅ‡∏£‡∏á‡∏ï‡∏•‡∏≤‡∏î‡∏û‡∏≠‡πÉ‡∏ä‡πâ ({strength_analysis['total_strength']:.2f}%)"
                strength_analysis['total_strength'] = 15.0  # ‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
            else:
                entry_reason = f"üöÄ UNLIMITED ENTRY: ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡πÅ‡∏£‡∏á‡∏ï‡∏•‡∏≤‡∏î‡∏ï‡πà‡∏≥ ({strength_analysis['total_strength']:.2f}%) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á"
                strength_analysis['total_strength'] = 10.0  # ‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
                logger.info(f"üöÄ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 2: {entry_reason}")
        
        logger.info(f"‚úÖ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 2: {entry_reason}")
            
        # 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Volume Filter (‡∏õ‡∏¥‡∏î‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß)
        # if volume_history and not self.candle_analyzer.check_volume_filter(candle.volume, volume_history):
        #     result['reasons'].append("Volume ‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏Å‡∏ì‡∏ë‡πå")
        #     logger.info(f"‚ùå ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 3: {result['reasons'][-1]}")
        #     return result
        # else:
        logger.info(f"‚úÖ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 3: Volume ‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ (‡∏Ç‡πâ‡∏≤‡∏° Volume Filter)")
            
        # 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏û‡∏≠‡∏£‡πå‡∏ï
        balance_check = self._check_portfolio_balance(positions, strength_analysis['direction'], force_balance_mode)
        if not balance_check['can_enter']:
            result['reasons'].extend(balance_check['reasons'])
            logger.info(f"‚ùå ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 4: {'; '.join(balance_check['reasons'])}")
            return result
        else:
            logger.info(f"‚úÖ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 4: ‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏û‡∏≠‡∏£‡πå‡∏ï‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°")
            
        # 5. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô (‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡∏Ç‡∏±‡∏î‡∏Å‡∏±‡∏ö Recovery Systems)
        # exposure_check = self._check_capital_exposure(positions, account_balance)
        # if not exposure_check['can_enter']:
        #     result['reasons'].extend(exposure_check['reasons'])
        #     logger.info(f"‚ùå ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 5: {'; '.join(exposure_check['reasons'])}")
        #     return result
        # else:
        logger.info(f"‚úÖ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 5: ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô (‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö - ‡πÄ‡∏û‡∏∑‡πà‡∏≠ Recovery Systems)")
            
        # üõ°Ô∏è Entry Price Validation - ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ú‡∏¥‡∏î
        entry_price = candle.close
        price_validation = self._validate_entry_price(strength_analysis['direction'], entry_price, candle.close)
        if not price_validation['valid']:
            result['can_enter'] = False
            result['reasons'].append(f"Entry price invalid: {price_validation['reason']}")
            result['signal'] = None
            return result
        
        # üóëÔ∏è Portfolio Quality Check REMOVED - ‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠
        # ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏£‡πå‡∏ï‡πÅ‡∏¢‡πà‡∏¢‡∏¥‡πà‡∏á‡πÅ‡∏¢‡πà‡∏´‡∏ô‡∏±‡∏Å ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ

        # üöÄ Adaptive Entry Control - ENHANCED for Balance Enforcement
        adaptive_control = self._check_adaptive_entry_control(positions, candle.close, strength_analysis['direction'])
        
        if adaptive_control['force_trade']:
            # ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö Counter-Trade ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏• Portfolio
            strength_analysis['direction'] = adaptive_control['forced_direction']
            force_balance_mode = True  # ‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö Balance
            logger.info(f"üöÄ Adaptive Force Trade: {adaptive_control['reason']}")
            logger.info(f"üõ°Ô∏è FORCE BALANCE MODE: ‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ö‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•")
        elif adaptive_control['should_block']:
            # ‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πà Balance ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            result['can_enter'] = False
            result['reasons'].append(adaptive_control['reason'])
            result['signal'] = None
            logger.warning(f"‚ùå BLOCKED: {adaptive_control['reason']}")
            return result

        # üõ°Ô∏è Dynamic Zone Protection - DISABLED for Zone-Based System
        # ‡πÄ‡∏î‡∏¥‡∏°‡∏à‡∏∞‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ Zone System ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏ó‡∏ô
        dynamic_zone_check = self._check_dynamic_zone_protection(positions, candle.close, strength_analysis['direction'])
        if dynamic_zone_check['force_counter_trade'] and not adaptive_control['force_trade']:
            # ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
            logger.info(f"üõ°Ô∏è Dynamic Zone Info: Would suggest {dynamic_zone_check['forced_direction']} - {dynamic_zone_check['reason']}")
            # ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô direction ‡πÉ‡∏´‡πâ Zone System ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à
        elif not dynamic_zone_check['can_enter'] and not adaptive_control['force_trade']:
            # ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Ñ
            logger.warning(f"‚ö†Ô∏è Dynamic Zone Warning: {dynamic_zone_check['reason']} - Let Zone System decide")
            # ‡πÑ‡∏°‡πà return ‡πÉ‡∏´‡πâ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠

        # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
        signal = Signal(
            direction=strength_analysis['direction'],
            symbol=symbol,  # ‡πÉ‡∏ä‡πâ symbol ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
            strength=strength_analysis['total_strength'],
            confidence=self._calculate_signal_confidence(strength_analysis, balance_check),
            timestamp=candle.timestamp,
            price=entry_price,
            comment=f"Validated signal: {strength_analysis['direction']} at {entry_price}"
        )
        
        # ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
        logger.info(f"üéâ ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏ó‡∏£‡∏î!")
        logger.info(f"   Signal: {signal.direction} {signal.symbol} @ {signal.price:.2f}")
        logger.info(f"   Strength: {signal.strength:.2f}%, Confidence: {signal.confidence:.2f}%")
        
        result['can_enter'] = True
        result['signal'] = signal
        result['reasons'].append("‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î")
        
        return result
        
    def _check_flexible_entry_conditions(self, candle: CandleData, positions: List[Position]) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÅ‡∏ö‡∏ö‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô
        
        Args:
            candle: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô
        """
        result = {
            'can_enter': False,
            'direction': None,
            'reason': ''
        }
        
        # ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 1: ‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏ó‡πà‡∏á (body ‚â• 70% ‡∏Ç‡∏≠‡∏á range)
        candle_range = candle.high - candle.low
        candle_body = abs(candle.close - candle.open)
        
        if candle_range > 0:
            body_ratio = candle_body / candle_range
            if body_ratio >= 0.7:  # body ‚â• 70% ‡∏Ç‡∏≠‡∏á range
                result['can_enter'] = True
                # üéØ FIXED: Counter-trend logic - ‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏û‡∏á
                if candle.is_green:  # ‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß = ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô
                    result['direction'] = 'SELL'  # ‡∏Ç‡∏≤‡∏¢‡∏ï‡∏≠‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á
                else:  # ‡πÅ‡∏ó‡πà‡∏á‡πÅ‡∏î‡∏á = ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡∏á
                    result['direction'] = 'BUY'   # ‡∏ã‡∏∑‡πâ‡∏≠‡∏ï‡∏≠‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡πà‡∏≥
                result['reason'] = f"‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏ó‡πà‡∏á (body {body_ratio*100:.1f}% ‡∏Ç‡∏≠‡∏á range)"
                logger.info(f"üéØ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô: {result['reason']}")
                return result
        
        # ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç 2: ‡∏õ‡∏¥‡∏î‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö)
        # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢
        if hasattr(self, 'previous_candle_close') and self.previous_candle_close:
            price_change_pct = ((candle.close - self.previous_candle_close) / self.previous_candle_close) * 100
            
            # ‡∏ñ‡πâ‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á ‚â• 0.02% (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥)
            if abs(price_change_pct) >= 0.02:
                result['can_enter'] = True
                # üéØ FIXED: Counter-trend logic - ‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏û‡∏á
                if price_change_pct > 0:  # ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô
                    result['direction'] = 'SELL'  # ‡∏Ç‡∏≤‡∏¢‡∏ï‡∏≠‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á
                else:  # ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡∏á
                    result['direction'] = 'BUY'   # ‡∏ã‡∏∑‡πâ‡∏≠‡∏ï‡∏≠‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡πà‡∏≥
                result['reason'] = f"‡∏õ‡∏¥‡∏î{'‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤' if price_change_pct > 0 else '‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤'}‡πÅ‡∏ó‡πà‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤ ({price_change_pct:+.3f}%)"
                logger.info(f"üéØ ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô: {result['reason']}")
                
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏¥‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ó‡πà‡∏á‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
        self.previous_candle_close = candle.close
        
        if not result['can_enter']:
            logger.info(f"‚è∏Ô∏è ‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô")
            
        return result
        
    def _check_portfolio_balance(self, positions: List[Position], direction: str, force_balance_mode: bool = False) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏û‡∏≠‡∏£‡πå‡∏ï‡πÅ‡∏ö‡∏ö Zone-Based (100 ‡∏à‡∏∏‡∏î = 10 pips)
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position
            direction: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ó‡∏£‡∏î
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•
        """
        result = {
            'can_enter': True,
            'reasons': []
        }
        
        if not positions:
            return result
            
        # üéØ Zone-Based Balance Check (100 points = 10 pips per zone)
        zone_balance = self._analyze_zone_balance(positions, direction)
        
        # ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ position ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 5 ‡∏ï‡∏±‡∏ß ‡πÑ‡∏°‡πà‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏°‡∏î‡∏∏‡∏• zone
        if len(positions) < 5:
            logger.info(f"üí° ‡∏°‡∏µ Position {len(positions)} ‡∏ï‡∏±‡∏ß - ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ Zone Balance")
        else:
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏°‡∏î‡∏∏‡∏• zone ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ position ‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß
            current_zone = zone_balance['current_zone']
            zone_imbalance = zone_balance['zone_imbalance']
            
            # ‡∏ñ‡πâ‡∏≤ zone ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏°‡∏î‡∏∏‡∏• (‡πÄ‡∏Å‡∏¥‡∏ô 3 zones)
            if zone_imbalance > 3:
                if direction == "BUY" and zone_balance['buy_heavy']:
                    result['can_enter'] = False
                    result['reasons'].append(f"Zone {current_zone} BUY heavy: {zone_imbalance} zones imbalance")
                elif direction == "SELL" and zone_balance['sell_heavy']:
                    result['can_enter'] = False
                    result['reasons'].append(f"Zone {current_zone} SELL heavy: {zone_imbalance} zones imbalance")
                    
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Price Hierarchy Rule (‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å‡∏Ç‡∏≤‡∏¢‡πÅ‡∏û‡∏á) - ‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠ Force Balance
        if not force_balance_mode:  # ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÇ‡∏´‡∏°‡∏î‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö Balance
            hierarchy_check = self._check_price_hierarchy(positions, direction)
            if not hierarchy_check['valid']:
                result['can_enter'] = False
                result['reasons'].append(hierarchy_check['reason'])
        else:
            logger.info(f"üõ°Ô∏è FORCE BALANCE: ‡∏Ç‡πâ‡∏≤‡∏° Price Hierarchy check ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•")
            
        return result
    
    def _analyze_zone_balance(self, positions: List[Position], direction: str) -> Dict[str, Any]:
        """
        üéØ ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏°‡∏î‡∏∏‡∏•‡πÅ‡∏ö‡∏ö Zone-Based (100 ‡∏à‡∏∏‡∏î = 10 pips ‡∏ï‡πà‡∏≠ zone)
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ positions
            direction: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ó‡∏£‡∏î
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå zone balance
        """
        if not positions:
            return {'current_zone': 0, 'zone_imbalance': 0, 'buy_heavy': False, 'sell_heavy': False}
        
        # ‡∏´‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏à‡∏≤‡∏Å positions)
        current_price = sum(pos.price_open for pos in positions) / len(positions)
        
        # ‡πÅ‡∏ö‡πà‡∏á positions ‡πÄ‡∏õ‡πá‡∏ô zones (100 points = 10 pips per zone)
        zone_size = 1.0  # 100 points = 1.0 price units ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö XAUUSD
        zones = {}
        
        for pos in positions:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì zone number ‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤
            zone_num = int(pos.price_open / zone_size)
            
            if zone_num not in zones:
                zones[zone_num] = {'BUY': 0, 'SELL': 0, 'total': 0}
            
            pos_type = "BUY" if pos.type == 0 else "SELL"
            zones[zone_num][pos_type] += 1
            zones[zone_num]['total'] += 1
        
        # ‡∏´‡∏≤ zone ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        current_zone = int(current_price / zone_size)
        
        # ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏°‡πà‡∏™‡∏°‡∏î‡∏∏‡∏•
        max_imbalance = 0
        buy_heavy = False
        sell_heavy = False
        
        for zone_num, counts in zones.items():
            if counts['total'] >= 3:  # ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ zone ‡∏ó‡∏µ‡πà‡∏°‡∏µ positions >= 3 ‡∏ï‡∏±‡∏ß
                buy_ratio = counts['BUY'] / counts['total']
                sell_ratio = counts['SELL'] / counts['total']
                
                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏°‡πà‡∏™‡∏°‡∏î‡∏∏‡∏• (0.8 = 80%)
                if buy_ratio >= 0.8:
                    imbalance = abs(zone_num - current_zone)
                    if imbalance > max_imbalance:
                        max_imbalance = imbalance
                        buy_heavy = True
                        sell_heavy = False
                elif sell_ratio >= 0.8:
                    imbalance = abs(zone_num - current_zone)
                    if imbalance > max_imbalance:
                        max_imbalance = imbalance
                        buy_heavy = False
                        sell_heavy = True
        
        return {
            'current_zone': current_zone,
            'zone_imbalance': max_imbalance,
            'buy_heavy': buy_heavy,
            'sell_heavy': sell_heavy,
            'total_zones': len(zones)
        }
    
    def _check_price_hierarchy(self, positions: List[Position], direction: str) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Price Hierarchy Rule
        Buy Orders ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ Sell Orders ‡πÄ‡∏™‡∏°‡∏≠
        ‡πÅ‡∏ï‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡∏¥‡∏î Breakout ‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ Continuous Trading
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position
            direction: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ó‡∏£‡∏î
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        """
        if not positions:
            return {'valid': True, 'reason': ''}
            
        buy_prices = [pos.price_open for pos in positions if pos.type == 0]  # BUY
        sell_prices = [pos.price_open for pos in positions if pos.type == 1]  # SELL
        
        if not buy_prices or not sell_prices:
            return {'valid': True, 'reason': ''}
            
        max_buy_price = max(buy_prices)
        min_sell_price = min(sell_prices)
        
        if max_buy_price >= min_sell_price:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô Breakout Scenario ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            gap_pips = (max_buy_price - min_sell_price) * 10  # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô pips
            
            # ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏ß‡πà‡∏≤: ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏ñ‡πâ‡∏≤ gap ‡πÑ‡∏°‡πà‡πÉ‡∏´‡∏ç‡πà‡∏°‡∏≤‡∏Å (< 50 pips = 500 ‡∏à‡∏∏‡∏î)
            if gap_pips < 50.0:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 150 ‡πÄ‡∏õ‡πá‡∏ô 50 pips ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö 10 pips spacing
                logger.info(f"‚ö° Price Hierarchy Override: Gap={gap_pips:.1f} pips ({gap_pips*10:.0f} ‡∏à‡∏∏‡∏î) - Normal Trading")
                return {'valid': True, 'reason': f'Acceptable gap - {gap_pips:.1f} pips < 50 pips'}
            
            # ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏ñ‡πâ‡∏≤‡∏°‡∏µ positions ‡∏ô‡πâ‡∏≠‡∏¢ (< 10 ‡πÑ‡∏°‡πâ) - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 5 ‡πÄ‡∏õ‡πá‡∏ô 10
            if len(positions) < 10:
                logger.info(f"‚ö° Price Hierarchy Override: Only {len(positions)} positions (Allow flexibility)")
                return {'valid': True, 'reason': f'Few positions ({len(positions)}) - Allow flexibility'}
            
            # ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏ñ‡πâ‡∏≤‡∏°‡∏µ positions ‡πÄ‡∏¢‡∏≠‡∏∞‡∏°‡∏≤‡∏Å (> 15 ‡πÑ‡∏°‡πâ) - ‡πÄ‡∏û‡∏∑‡πà‡∏≠ recovery
            if len(positions) > 15:
                logger.info(f"‚ö° Price Hierarchy Override: Many positions ({len(positions)}) - Recovery mode")
                return {'valid': True, 'reason': f'Many positions ({len(positions)}) - Recovery priority'}
            
            return {
                'valid': False,
                'reason': f'Price hierarchy violated: Max BUY ({max_buy_price}) >= Min SELL ({min_sell_price}) - Gap: {gap_pips:.1f} pips'
            }
            
        return {'valid': True, 'reason': ''}
    
    def _check_dynamic_zone_protection(self, positions: List[Position], current_price: float, direction: str) -> Dict[str, Any]:
        """
        üõ°Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Price Inversion ‡πÅ‡∏ö‡∏ö Dynamic Zone
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ positions ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            current_price: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            direction: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Dynamic Zone
        """
        result = {
            'can_enter': True,
            'force_counter_trade': False,
            'forced_direction': direction,
            'reason': ''
        }
        
        if not positions or len(positions) < 3:
            return result
            
        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï zones
        zone_boundaries = self._calculate_zone_boundaries(positions)
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Force Counter Trade
        force_check = self._should_force_counter_trade(positions, current_price, zone_boundaries)
        
        if force_check['should_force']:
            result['force_counter_trade'] = True
            result['forced_direction'] = force_check['forced_direction']
            result['reason'] = force_check['reason']
            return result
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ö‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢
        if self._is_in_danger_zone(current_price, zone_boundaries, direction):
            result['can_enter'] = False
            result['reason'] = f"Price in danger zone for {direction} at {current_price:.2f}"
            
        return result
    
    def _calculate_zone_boundaries(self, positions: List[Position]) -> Dict[str, float]:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï Upper/Lower Zone"""
        buy_positions = [pos for pos in positions if pos.type == 0]  # BUY
        sell_positions = [pos for pos in positions if pos.type == 1]  # SELL
        
        zone_buffer = 20.0  # 200 pips = 20.0 points ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö XAUUSD
        
        boundaries = {
            'upper_zone_start': 0.0,
            'lower_zone_start': 0.0,
            'safe_range_top': 0.0,
            'safe_range_bottom': 0.0
        }
        
        if sell_positions:
            max_sell_price = max(pos.price_open for pos in sell_positions)
            boundaries['upper_zone_start'] = max_sell_price + zone_buffer
            boundaries['safe_range_top'] = max_sell_price + (zone_buffer * 0.5)
            
        if buy_positions:
            min_buy_price = min(pos.price_open for pos in buy_positions)
            boundaries['lower_zone_start'] = min_buy_price - zone_buffer
            boundaries['safe_range_bottom'] = min_buy_price - (zone_buffer * 0.5)
            
        return boundaries
    
    def _should_force_counter_trade(self, positions: List[Position], current_price: float, boundaries: Dict[str, float]) -> Dict[str, Any]:
        """‚ö° ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á Force Trade ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        result = {
            'should_force': False,
            'forced_direction': '',
            'reason': ''
        }
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Upper Zone (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‚Üí ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö SELL)
        if boundaries['upper_zone_start'] > 0 and current_price >= boundaries['upper_zone_start']:
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ SELL ‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            sell_positions = [pos for pos in positions if pos.type == 1 and pos.price_open >= boundaries['upper_zone_start']]
            
            if not sell_positions:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ SELL ‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏ö‡∏ô ‚Üí ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö SELL
                result['should_force'] = True
                result['forced_direction'] = 'SELL'
                result['reason'] = f"Force SELL: Price {current_price:.2f} above upper zone {boundaries['upper_zone_start']:.2f}, no SELL positions in zone"
                
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Lower Zone (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡πà‡∏≥‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‚Üí ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö BUY)
        elif boundaries['lower_zone_start'] > 0 and current_price <= boundaries['lower_zone_start']:
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ BUY ‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            buy_positions = [pos for pos in positions if pos.type == 0 and pos.price_open <= boundaries['lower_zone_start']]
            
            if not buy_positions:  # ‡πÑ‡∏°‡πà‡∏°‡∏µ BUY ‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏•‡πà‡∏≤‡∏á ‚Üí ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö BUY
                result['should_force'] = True
                result['forced_direction'] = 'BUY'
                result['reason'] = f"Force BUY: Price {current_price:.2f} below lower zone {boundaries['lower_zone_start']:.2f}, no BUY positions in zone"
                
        return result
    
    def _is_in_danger_zone(self, current_price: float, boundaries: Dict[str, float], direction: str) -> bool:
        """üö® ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Ñ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô
        # ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï
        return False
        
    def _check_capital_exposure(self, positions: List[Position], account_balance: float, 
                               max_exposure_percentage: float = 65.0) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position
            account_balance: ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ
            max_exposure_percentage: ‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        """
        result = {
            'can_enter': True,
            'reasons': []
        }
        
        if not positions:
            return result
            
        exposure_percentage = PercentageCalculator.calculate_portfolio_exposure_percentage(
            positions, account_balance
        )
        
        # ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô: ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏ô 5% ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ positions ‡∏ô‡πâ‡∏≠‡∏¢
        total_positions = len(positions)
        flexible_limit = max_exposure_percentage
        
        # ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ positions ‡∏ô‡πâ‡∏≠‡∏¢ ‡πÉ‡∏´‡πâ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô
        if total_positions <= 3:
            flexible_limit = max_exposure_percentage + 10  # ‡πÄ‡∏û‡∏¥‡πà‡∏° 10%
        elif total_positions <= 5:
            flexible_limit = max_exposure_percentage + 5   # ‡πÄ‡∏û‡∏¥‡πà‡∏° 5%
        
        if exposure_percentage >= flexible_limit:
            result['can_enter'] = False
            result['reasons'].append(
                f"‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô {flexible_limit}% ({exposure_percentage:.1f}%) - Positions: {total_positions}"
            )
        elif exposure_percentage >= max_exposure_percentage:
            # ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï
            logger.warning(f"‚ö†Ô∏è ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Å‡∏¥‡∏ô: {exposure_percentage:.1f}% (‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î {max_exposure_percentage}%)")
        
        return result
        
    def _calculate_signal_confidence(self, strength_analysis: Dict, balance_check: Dict) -> float:
        """
        ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
        
        Args:
            strength_analysis: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏£‡∏á
            balance_check: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•
            
        Returns:
            float: ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à (0-100)
        """
        base_confidence = strength_analysis['total_strength']
        
        # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏û‡∏≠‡∏£‡πå‡∏ï
        if balance_check['can_enter']:
            balance_bonus = 20.0
        else:
            balance_bonus = 0.0
            
        # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Volume
        volume_bonus = strength_analysis['volume_strength'] * 0.2
        
        total_confidence = min(100, base_confidence + balance_bonus + volume_bonus)
        return total_confidence
        
    def check_exit_conditions(self, positions: List[Position], account_balance: float,
                            current_prices: Dict[str, float]) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î Orders
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position
            account_balance: ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ
            current_prices: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ï‡πà‡∏≤‡∏á‡πÜ
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î
        """
        result = {
            'should_exit': False,
            'exit_type': '',
            'positions_to_close': [],
            'reasons': []
        }
        
        if not positions:
            return result
            
        # üóëÔ∏è ALL EXIT LOGIC REMOVED - Now handled by Smart Profit Taking System
        logger.debug("üóëÔ∏è Exit conditions removed - all exits handled by Smart Profit Taking System")
        return {
            'should_exit': False,
            'reason': 'Exit conditions removed - using Smart Profit Taking System only',
            'exit_type': None
        }
        
    def _validate_entry_price(self, direction: str, entry_price: float, current_price: float) -> Dict[str, Any]:
        """
        üõ°Ô∏è ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á - ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡πÅ‡∏û‡∏á‡∏Ç‡∏≤‡∏¢‡∏ñ‡∏π‡∏Å
        
        Args:
            direction: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î BUY/SELL
            entry_price: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ
            current_price: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        """
        result = {'valid': True, 'reason': 'Price validation passed'}
        
        try:
            if direction == "BUY":
                # BUY ‡∏ï‡πâ‡∏≠‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô)
                if entry_price > current_price:
                    result['valid'] = False
                    result['reason'] = f"BUY price {entry_price:.2f} > current {current_price:.2f} (would buy expensive)"
                    
            elif direction == "SELL":
                # SELL ‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡πÅ‡∏û‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô)
                if entry_price < current_price:
                    result['valid'] = False
                    result['reason'] = f"SELL price {entry_price:.2f} < current {current_price:.2f} (would sell cheap)"
                    
        except Exception as e:
            result['valid'] = False
            result['reason'] = f"Price validation error: {e}"
            
        return result
    
    def _assess_portfolio_quality(self, positions: List[Position], current_price: float) -> Dict[str, Any]:
        """
        üîç ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡∏û‡∏≠‡∏£‡πå‡∏ï - ‡∏î‡∏π‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ positions
            current_price: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô
        """
        result = {
            'total_positions': 0,
            'good_positions': 0,
            'bad_positions': 0,
            'good_position_ratio': 0.0,
            'bad_position_ratio': 0.0,
            'quality_score': 0.0
        }
        
        try:
            if not positions:
                result['quality_score'] = 100.0  # ‡∏û‡∏≠‡∏£‡πå‡∏ï‡∏ß‡πà‡∏≤‡∏á = ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏î‡∏µ
                return result
                
            total_positions = len(positions)
            good_positions = 0
            bad_positions = 0
            
            for pos in positions:
                if hasattr(pos, 'type') and hasattr(pos, 'price_open'):
                    pos_type = pos.type.upper() if isinstance(pos.type, str) else ("BUY" if pos.type == 0 else "SELL")
                    
                    # ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
                    if pos_type == "BUY" and pos.price_open < current_price:
                        good_positions += 1  # ‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å - ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Å‡∏≥‡πÑ‡∏£
                    elif pos_type == "SELL" and pos.price_open > current_price:
                        good_positions += 1  # ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏û‡∏á - ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Å‡∏≥‡πÑ‡∏£
                    else:
                        bad_positions += 1   # ‡∏≠‡∏¢‡∏π‡πà‡∏ú‡∏¥‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á - ‡∏ï‡∏¥‡∏î‡∏•‡∏ö
            
            result['total_positions'] = total_positions
            result['good_positions'] = good_positions
            result['bad_positions'] = bad_positions
            result['good_position_ratio'] = good_positions / total_positions
            result['bad_position_ratio'] = bad_positions / total_positions
            result['quality_score'] = (good_positions / total_positions) * 100
            
        except Exception as e:
            logger.error(f"Error assessing portfolio quality: {e}")
            result['quality_score'] = 0.0
            
        return result
    
    # üóëÔ∏è OLD PROFIT/STOP LOSS METHODS REMOVED
    # Replaced by Lightning Portfolio Cleanup System
        
    def _check_pullback_conditions(self, positions: List[Position], current_prices: Dict[str, float],
                                  min_pullback_percentage: float = 0.3) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç Pullback Wait Strategy
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position
            current_prices: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            min_pullback_percentage: ‡πÄ‡∏Å‡∏ì‡∏ë‡πå Pullback ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        """
        # ‡∏´‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á positions
        if not positions:
            return {'should_wait': False}
            
        highest_price = max(pos.price_open for pos in positions)
        lowest_price = min(pos.price_open for pos in positions)
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå
        for symbol, current_price in current_prices.items():
            # ‡∏ñ‡πâ‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏Å‡∏¥‡∏ô highest position
            if current_price > highest_price:
                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì pullback
                pullback_pct = MarketAnalysisCalculator.calculate_pullback_percentage(
                    current_price, current_price, lowest_price
                )
                
                if pullback_pct < min_pullback_percentage:
                    return {
                        'should_wait': True,
                        'reason': f'‡∏£‡∏≠ Pullback {min_pullback_percentage}% (‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô {pullback_pct:.2f}%)'
                    }
                    
        return {'should_wait': False}
        
    def _check_group_pnl(self, positions: List[Position], account_balance: float) -> Dict[str, Any]:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≥‡πÑ‡∏£‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position
            account_balance: ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        """
        group_profit_pct = PercentageCalculator.calculate_group_profit_percentage(
            positions, account_balance
        )
        
        # ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏ß‡∏Å
        if group_profit_pct > 0:
            return {
                'should_exit': True,
                'exit_type': 'group_profit',
                'positions_to_close': positions,
                'reasons': [f'‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏°‡∏µ‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏° {group_profit_pct:.2f}%']
            }
            
        return {'should_exit': False}
        
    def register_order_for_candle(self, candle_time: datetime):
        """
        ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô Order ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô
        
        Args:
            candle_time: ‡πÄ‡∏ß‡∏•‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô
        """
        candle_time_key = candle_time.strftime("%Y%m%d%H%M")
        if candle_time_key not in self.orders_per_candle:
            self.orders_per_candle[candle_time_key] = 0
        self.orders_per_candle[candle_time_key] += 1
        
    def cleanup_old_candle_records(self, hours_to_keep: int = 24):
        """
        ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Order ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡πÄ‡∏Å‡πà‡∏≤
        
        Args:
            hours_to_keep: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        """
        current_time = datetime.now()
        cutoff_time = current_time - timedelta(hours=hours_to_keep)
        
        keys_to_remove = []
        for key in self.orders_per_candle.keys():
            try:
                candle_time = datetime.strptime(key, "%Y%m%d%H%M")
                if candle_time < cutoff_time:
                    keys_to_remove.append(key)
            except ValueError:
                keys_to_remove.append(key)  # ‡∏•‡∏ö key ‡∏ó‡∏µ‡πà format ‡∏ú‡∏¥‡∏î
                
        for key in keys_to_remove:
            del self.orders_per_candle[key]
    
    def _calculate_market_volatility(self, candle: CandleData) -> float:
        """üß† ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡∏•‡∏≤‡∏î"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì ATR-like volatility
            candle_range = candle.high - candle.low
            price_avg = (candle.high + candle.low) / 2
            volatility_pct = (candle_range / price_avg) * 100 if price_avg > 0 else 0
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á 0.1 - 3.0
            volatility_factor = max(0.1, min(3.0, volatility_pct / 0.1))
            
            logger.debug(f"üìä Market Volatility: {volatility_pct:.3f}% ‚Üí Factor: {volatility_factor:.2f}")
            return volatility_factor
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating volatility: {e}")
            return 1.0  # Default volatility
    
    def _get_adaptive_entry_limit(self, volatility_factor: float, position_count: int) -> int:
        """üöÄ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏î Entry Limit ‡πÅ‡∏ö‡∏ö Adaptive"""
        try:
            # Base limit ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
            if volatility_factor > 2.0:
                base_limit = 8  # ‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏™‡∏π‡∏á = ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏î‡πâ‡∏ö‡πà‡∏≠‡∏¢
            elif volatility_factor > 1.5:
                base_limit = 6  # ‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            elif volatility_factor > 1.0:
                base_limit = 4  # ‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏ï‡πà‡∏≥
            else:
                base_limit = 2  # ‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏ï‡πà‡∏≥‡∏°‡∏≤‡∏Å
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô positions
            if position_count > 200:
                adjustment = 0.5  # ‡∏°‡∏µ‡πÑ‡∏°‡πâ‡πÄ‡∏¢‡∏≠‡∏∞ ‚Üí ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤
            elif position_count > 100:
                adjustment = 0.7
            elif position_count > 50:
                adjustment = 0.9
            else:
                adjustment = 1.2  # ‡∏°‡∏µ‡πÑ‡∏°‡πâ‡∏ô‡πâ‡∏≠‡∏¢ ‚Üí ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤
            
            final_limit = max(1, int(base_limit * adjustment))
            
            logger.debug(f"üöÄ Entry Limit: Base:{base_limit} √ó Adj:{adjustment:.2f} = {final_limit} entries/min")
            return final_limit
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating entry limit: {e}")
            return 3  # Safe default
    
    def _check_adaptive_entry_control(self, positions: List[Position], current_price: float, direction: str) -> Dict[str, Any]:
        """
        üöÄ Adaptive Entry Control - ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Unlimited Entry + Smart Management
        
        Args:
            positions: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ positions
            current_price: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            direction: ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        """
        result = {
            'should_block': False,
            'force_trade': False,
            'reason': '',
            'forced_direction': direction
        }
        
        if not positions:
            return result
            
        # üè• ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û Portfolio
        wrong_buys = sum(1 for pos in positions if pos.type == 0 and pos.price_open > current_price)
        wrong_sells = sum(1 for pos in positions if pos.type == 1 and pos.price_open < current_price)
        total_positions = len(positions)
        wrong_percentage = ((wrong_buys + wrong_sells) / total_positions) * 100 if total_positions > 0 else 0
        
        # üéØ Smart Imbalance Detection & Counter-Trade Logic
        buy_count = sum(1 for pos in positions if pos.type == 0)
        sell_count = sum(1 for pos in positions if pos.type == 1)
        buy_percentage = (buy_count / total_positions) * 100 if total_positions > 0 else 0
        sell_percentage = (sell_count / total_positions) * 100 if total_positions > 0 else 0
        
        # üöÄ SMART LOGIC: ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏™‡∏°‡∏î‡∏∏‡∏• ‚Üí Force Counter-Trade (‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô)
        if sell_percentage > 65.0:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 80% ‡πÄ‡∏õ‡πá‡∏ô 65%
            # Portfolio ‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡πÑ‡∏õ SELL ‡∏°‡∏≤‡∏Å ‚Üí ‡∏ï‡πâ‡∏≠‡∏á BUY ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•
            if direction == "BUY":
                result['force_trade'] = True
                result['reason'] = f'üöÄ SMART: Force BUY to balance (SELL: {sell_percentage:.1f}%)'
                logger.info(f"üöÄ FORCE BUY: Portfolio ‡πÄ‡∏≠‡∏µ‡∏¢‡∏á SELL {sell_percentage:.1f}% ‚Üí ‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å‡πÅ‡∏Å‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•")
                return result
            else:  # direction == "SELL"
                result['should_block'] = True
                result['reason'] = f'‚ùå BLOCK: Too many SELL already ({sell_percentage:.1f}%)'
                return result
                
        elif buy_percentage > 65.0:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 80% ‡πÄ‡∏õ‡πá‡∏ô 65%
            # Portfolio ‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡πÑ‡∏õ BUY ‡∏°‡∏≤‡∏Å ‚Üí ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö SELL ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•
            result['force_trade'] = True
            result['forced_direction'] = "SELL"  # ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö SELL ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤ signal ‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏∞‡πÑ‡∏£
            result['reason'] = f'üöÄ FORCE SELL: Too many BUY ({buy_percentage:.1f}%) - Must balance!'
            logger.info(f"üöÄ FORCE SELL: Portfolio ‡πÄ‡∏≠‡∏µ‡∏¢‡∏á BUY {buy_percentage:.1f}% ‚Üí ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏Ç‡∏≤‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏™‡∏°‡∏î‡∏∏‡∏•")
            return result
        
        elif total_positions > 50:
            # üü° High Volume Mode: ‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Ñ
            logger.info(f"üü° High Volume Mode: {total_positions} positions, Wrong: {wrong_percentage:.1f}%")
            result['reason'] = f'High Volume Mode: Proceed with caution'
            return result
        
        # üü¢ Normal Mode: ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏ó‡∏∏‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤ (Unlimited Entry)
        result['reason'] = f'Normal Mode: Unlimited entry allowed (Wrong: {wrong_percentage:.1f}%)'
        return result
