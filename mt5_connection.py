# -*- coding: utf-8 -*-
"""
MT5 Connection Module
‡πÇ‡∏°‡∏î‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ MetaTrader 5
"""

import logging
import time
from typing import Optional, Dict, List, Any
from datetime import datetime

# Safe import for MT5
try:
    import MetaTrader5 as mt5
    MT5_AVAILABLE = True
except ImportError:
    print("WARNING: MetaTrader5 not available - running in simulation mode")
    mt5 = None
    MT5_AVAILABLE = False

logger = logging.getLogger(__name__)

class MT5Connection:
    """‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5"""
    
    def __init__(self):
        self.is_connected = False
        self.terminal_info = None
        self.account_info = None
        self.last_connection_check = None
        self.broker_symbols = {}  # ‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Ç‡∏≠‡∏á‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå
        self.filling_types = {}   # ‡πÄ‡∏Å‡πá‡∏ö filling type ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå
        
    def connect_mt5(self, max_retries: int = 3, retry_delay: float = 2.0) -> bool:
        """
        ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 Terminal
        
        Args:
            max_retries: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            retry_delay: ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°
            
        Returns:
            bool: ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        """
        if not MT5_AVAILABLE:
            logger.error("MT5 module not available")
            return False
            
        for attempt in range(max_retries):
            try:
                logger.info(f"‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà {attempt + 1}")
                
                # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
                if mt5.initialize():
                    self.is_connected = True
                    self.terminal_info = mt5.terminal_info()
                    self.account_info = mt5.account_info()
                    self.last_connection_check = datetime.now()
                    
                    # ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Ç‡∏≠‡∏á‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå
                    self._load_broker_symbols()
                    
                    logger.info(f"‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - Terminal: {self.terminal_info.name}")
                    logger.info(f"Account: {self.account_info.login}, Balance: {self.account_info.balance}")
                    logger.info(f"‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÑ‡∏î‡πâ {len(self.broker_symbols)} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£")
                    return True
                    
                else:
                    error = mt5.last_error()
                    logger.error(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡πÑ‡∏î‡πâ: {error}")
                    
            except Exception as e:
                logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5: {e}")
                
            if attempt < max_retries - 1:
                logger.info(f"‡∏£‡∏≠ {retry_delay} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏Å‡πà‡∏≠‡∏ô‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà...")
                time.sleep(retry_delay)
                
        logger.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°")
        return False
        
    def connect_to_specific_terminal(self, terminal_path: str, max_retries: int = 3, retry_delay: float = 2.0) -> bool:
        """
        ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 Terminal ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏ path
        
        Args:
            terminal_path: path ‡∏Ç‡∏≠‡∏á MT5 Terminal
            max_retries: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            retry_delay: ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°
            
        Returns:
            bool: ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        """
        if not MT5_AVAILABLE:
            logger.error("MT5 module not available")
            return False
            
        for attempt in range(max_retries):
            try:
                logger.info(f"‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡∏ó‡∏µ‡πà {terminal_path} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà {attempt + 1}")
                
                # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö terminal ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
                if mt5.initialize(path=terminal_path):
                    self.is_connected = True
                    self.terminal_info = mt5.terminal_info()
                    self.account_info = mt5.account_info()
                    self.last_connection_check = datetime.now()
                    
                    logger.info(f"‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - Terminal: {self.terminal_info.name}")
                    logger.info(f"Path: {terminal_path}")
                    logger.info(f"Account: {self.account_info.login}, Balance: {self.account_info.balance}")
                    return True
                    
                else:
                    error = mt5.last_error()
                    logger.error(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡πÑ‡∏î‡πâ: {error}")
                    
            except Exception as e:
                logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5: {e}")
                
            if attempt < max_retries - 1:
                logger.info(f"‡∏£‡∏≠ {retry_delay} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏Å‡πà‡∏≠‡∏ô‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà...")
                time.sleep(retry_delay)
                
        logger.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°")
        return False
        
    def check_connection_health(self) -> bool:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5
        
        Returns:
            bool: ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        """
        if not MT5_AVAILABLE or not self.is_connected:
            return False
            
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å terminal info
            terminal_info = mt5.terminal_info()
            if terminal_info is None:
                logger.warning("‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡∏´‡∏•‡∏∏‡∏î")
                self.is_connected = False
                return False
                
            # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó account info
            self.account_info = mt5.account_info()
            self.last_connection_check = datetime.now()
            return True
            
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: {e}")
            self.is_connected = False
            return False
            
    def attempt_reconnection(self) -> bool:
        """
        ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà
        
        Returns:
            bool: ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        """
        logger.info("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡πÉ‡∏´‡∏°‡πà...")
        
        # ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô
        self.disconnect_mt5()
        
        # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà
        return self.connect_mt5()
        
    def disconnect_mt5(self):
        """‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5"""
        if MT5_AVAILABLE and self.is_connected:
            try:
                mt5.shutdown()
                logger.info("‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5 ‡πÅ‡∏•‡πâ‡∏ß")
            except Exception as e:
                logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ MT5: {e}")
                
        self.is_connected = False
        self.terminal_info = None
        self.account_info = None
        self.last_connection_check = None
        
    def get_account_info(self) -> Optional[Dict]:
        """
        ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Account
        
        Returns:
            Dict: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Account ‡∏´‡∏£‡∏∑‡∏≠ None
        """
        if not self.check_connection_health():
            return None
            
        try:
            account_info = mt5.account_info()
            if account_info:
                # ‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏à‡∏£‡∏¥‡∏á
                if hasattr(account_info, 'trade_mode'):
                    if account_info.trade_mode == 0:  # Real account
                        logger.warning("üö® ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏à‡∏£‡∏¥‡∏á (REAL ACCOUNT) - ‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏£‡∏¥‡∏á!")
                    elif account_info.trade_mode == 1:  # Demo account  
                        logger.info("‚úÖ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏î‡∏•‡∏≠‡∏á (DEMO ACCOUNT)")
                    elif account_info.trade_mode == 2:  # Contest account
                        logger.info("üèÜ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÅ‡∏Ç‡πà‡∏á‡∏Ç‡∏±‡∏ô (CONTEST ACCOUNT)")
                
                return {
                    'login': account_info.login,
                    'trade_mode': getattr(account_info, 'trade_mode', 'Unknown'),
                    'balance': account_info.balance,
                    'equity': account_info.equity,
                    'margin': account_info.margin,
                    'margin_free': account_info.margin_free,
                    'margin_level': account_info.margin_level,
                    'profit': account_info.profit,
                    'currency': account_info.currency,
                    'leverage': account_info.leverage
                }
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Account: {e}")
            
        return None
        
    def get_terminal_info(self) -> Optional[Dict]:
        """
        ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Terminal
        
        Returns:
            Dict: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Terminal ‡∏´‡∏£‡∏∑‡∏≠ None
        """
        if not self.check_connection_health():
            return None
            
        try:
            terminal_info = mt5.terminal_info()
            if terminal_info:
                return {
                    'name': terminal_info.name,
                    'path': terminal_info.path,
                    'data_path': terminal_info.data_path,
                    'commondata_path': terminal_info.commondata_path,
                    'build': terminal_info.build,
                    'connected': terminal_info.connected,
                    'trade_allowed': terminal_info.trade_allowed,
                    'tradeapi_disabled': terminal_info.tradeapi_disabled,
                    'x64': terminal_info.x64
                }
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Terminal: {e}")
            
        return None
        
    def get_symbol_info(self, symbol: str) -> Optional[Dict]:
        """
        ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
        
        Args:
            symbol: ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î (‡πÄ‡∏ä‡πà‡∏ô EURUSD)
            
        Returns:
            Dict: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå ‡∏´‡∏£‡∏∑‡∏≠ None
        """
        if not self.check_connection_health():
            return None
            
        try:
            symbol_info = mt5.symbol_info(symbol)
            if symbol_info:
                return {
                    'name': symbol_info.name,
                    'currency_base': symbol_info.currency_base,
                    'currency_profit': symbol_info.currency_profit,
                    'currency_margin': symbol_info.currency_margin,
                    'digits': symbol_info.digits,
                    'point': symbol_info.point,
                    'spread': symbol_info.spread,
                    'volume_min': symbol_info.volume_min,
                    'volume_max': symbol_info.volume_max,
                    'volume_step': symbol_info.volume_step,
                    'trade_contract_size': symbol_info.trade_contract_size,
                    'trade_tick_value': symbol_info.trade_tick_value,
                    'trade_tick_size': symbol_info.trade_tick_size,
                    'margin_initial': symbol_info.margin_initial,
                    'margin_maintenance': symbol_info.margin_maintenance,
                    'bid': symbol_info.bid,
                    'ask': symbol_info.ask,
                    'last': symbol_info.last,
                    'time': symbol_info.time
                }
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol}: {e}")
            
        return None
        
    def get_market_data(self, symbol: str, timeframe: int, count: int = 100) -> Optional[List[Dict]]:
        """
        ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤ (OHLC)
        
        Args:
            symbol: ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
            timeframe: ‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ (mt5.TIMEFRAME_*)
            count: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô
            
        Returns:
            List[Dict]: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠ None
        """
        if not self.check_connection_health():
            return None
            
        try:
            rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, count)
            if rates is not None and len(rates) > 0:
                return [
                    {
                        'time': rate[0],
                        'open': rate[1],
                        'high': rate[2],
                        'low': rate[3],
                        'close': rate[4],
                        'tick_volume': rate[5],
                        'spread': rate[6],
                        'real_volume': rate[7]
                    }
                    for rate in rates
                ]
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤ {symbol}: {e}")
            
        return None
        
    def get_positions(self) -> List[Dict]:
        """
        ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà
        
        Returns:
            List[Dict]: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position
        """
        if not self.check_connection_health():
            return []
            
        try:
            positions = mt5.positions_get()
            if positions:
                return [
                    {
                        'ticket': pos.ticket,
                        'symbol': pos.symbol,
                        'type': pos.type,
                        'volume': pos.volume,
                        'price_open': pos.price_open,
                        'price_current': pos.price_current,
                        'profit': pos.profit,
                        'swap': pos.swap,
                        'commission': pos.commission,
                        'time': pos.time,
                        'comment': pos.comment,
                        'magic': pos.magic
                    }
                    for pos in positions
                ]
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Position: {e}")
            
        return []
        
    def place_order(self, symbol: str, order_type: int, volume: float, 
                   price: float = 0, sl: float = 0, tp: float = 0, 
                   comment: str = "", magic: int = 0) -> Optional[Dict]:
        """
        ‡∏™‡πà‡∏á Order
        
        Args:
            symbol: ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
            order_type: ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó Order (mt5.ORDER_TYPE_*)
            volume: ‡∏Ç‡∏ô‡∏≤‡∏î lot
            price: ‡∏£‡∏≤‡∏Ñ‡∏≤ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö pending order)
            sl: Stop Loss
            tp: Take Profit
            comment: ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
            magic: Magic Number
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á Order ‡∏´‡∏£‡∏∑‡∏≠ None
        """
        if not self.check_connection_health():
            return None
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        trade_check = self._check_trading_allowed(symbol)
        if not trade_check['allowed']:
            logger.error(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ: {trade_check['reason']}")
            return {'retcode': 10017, 'error_description': trade_check['reason']}
            
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö filling type ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
            filling_type = self._detect_filling_type(symbol)
            
            # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• request
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": volume,
                "type": order_type,
                "price": price,
                "sl": sl,
                "tp": tp,
                "comment": comment,
                "magic": magic,
                "type_filling": filling_type,
            }
            
            # ‡∏™‡πà‡∏á Order
            logger.info(f"üöÄ ‡∏™‡πà‡∏á Order Request: {request}")
            result = mt5.order_send(request)
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
            if result is None:
                logger.error("‚ùå mt5.order_send() ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô None - MT5 ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")
                return None
                
            logger.info(f"üìã Order Result: retcode={result.retcode}, deal={result.deal}, order={result.order}")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö retcode
            if result.retcode == 10009:  # TRADE_RETCODE_DONE
                logger.info(f"‚úÖ ‡∏™‡πà‡∏á Order ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - Deal: {result.deal}, Order: {result.order}")
                return {
                    'retcode': result.retcode,
                    'deal': result.deal,
                    'order': result.order,
                    'volume': result.volume,
                    'price': result.price,
                    'bid': result.bid,
                    'ask': result.ask,
                    'comment': result.comment,
                    'request_id': result.request_id,
                    'retcode_external': result.retcode_external
                }
            else:
                # ‡πÅ‡∏™‡∏î‡∏á error code ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢
                error_desc = self._get_retcode_description(result.retcode)
                logger.error(f"‚ùå ‡∏™‡πà‡∏á Order ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - RetCode: {result.retcode} ({error_desc})")
                return {
                    'retcode': result.retcode,
                    'error_description': error_desc
                }
                
        except Exception as e:
            logger.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á Order: {e}")
            
        return None
        
    def _get_retcode_description(self, retcode: int) -> str:
        """‡πÅ‡∏õ‡∏• retcode ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢"""
        retcode_dict = {
            10009: "TRADE_RETCODE_DONE - ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
            10004: "TRADE_RETCODE_REQUOTE - ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà",
            10006: "TRADE_RETCODE_REJECT - ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò",
            10007: "TRADE_RETCODE_CANCEL - ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
            10008: "TRADE_RETCODE_PLACED - ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏ß‡∏≤‡∏á",
            10010: "TRADE_RETCODE_DONE_PARTIAL - ‡∏ó‡∏≥‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô",
            10011: "TRADE_RETCODE_ERROR - ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ",
            10012: "TRADE_RETCODE_TIMEOUT - ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤",
            10013: "TRADE_RETCODE_INVALID - ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
            10014: "TRADE_RETCODE_INVALID_VOLUME - Volume ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
            10015: "TRADE_RETCODE_INVALID_PRICE - ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
            10016: "TRADE_RETCODE_INVALID_STOPS - Stop Loss/Take Profit ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
            10017: "TRADE_RETCODE_TRADE_DISABLED - ‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î",
            10018: "TRADE_RETCODE_MARKET_CLOSED - ‡∏ï‡∏•‡∏≤‡∏î‡∏õ‡∏¥‡∏î",
            10019: "TRADE_RETCODE_NO_MONEY - ‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏û‡∏≠",
            10020: "TRADE_RETCODE_PRICE_CHANGED - ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô",
            10021: "TRADE_RETCODE_PRICE_OFF - ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ú‡∏¥‡∏î",
            10022: "TRADE_RETCODE_INVALID_EXPIRATION - ‡∏ß‡∏±‡∏ô‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
            10023: "TRADE_RETCODE_ORDER_CHANGED - ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á",
            10024: "TRADE_RETCODE_TOO_MANY_REQUESTS - ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ",
            10025: "TRADE_RETCODE_NO_CHANGES - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á",
            10026: "TRADE_RETCODE_SERVER_DISABLES_AT - Server ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô",
            10027: "TRADE_RETCODE_CLIENT_DISABLES_AT - Client ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô",
            10028: "TRADE_RETCODE_LOCKED - ‡∏ñ‡∏π‡∏Å‡∏•‡πá‡∏≠‡∏Ñ",
            10029: "TRADE_RETCODE_FROZEN - ‡∏ñ‡∏π‡∏Å‡πÅ‡∏ä‡πà‡πÅ‡∏Ç‡πá‡∏á",
            10030: "TRADE_RETCODE_INVALID_FILL - Fill type ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"
        }
        return retcode_dict.get(retcode, f"Unknown RetCode: {retcode}")
        
    def _check_trading_allowed(self, symbol: str) -> Dict[str, Any]:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Symbol
            symbol_info = mt5.symbol_info(symbol)
            if not symbol_info:
                return {'allowed': False, 'reason': f'‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol}'}
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Symbol ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ
            if not symbol_info.trade_mode:
                return {'allowed': False, 'reason': f'‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol} ‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡∏£‡∏î'}
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏ó‡∏£‡∏î
            import datetime
            now = datetime.datetime.now()
            weekday = now.weekday()  # 0=Monday, 6=Sunday
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡∏™‡∏∏‡∏î‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Forex)
            if weekday == 5 and now.hour >= 22:  # Friday after 22:00
                return {'allowed': False, 'reason': '‡∏ï‡∏•‡∏≤‡∏î‡∏õ‡∏¥‡∏î‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå'}
            elif weekday == 6:  # Saturday
                return {'allowed': False, 'reason': '‡∏ï‡∏•‡∏≤‡∏î‡∏õ‡∏¥‡∏î‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏™‡∏≤‡∏£‡πå'}
            elif weekday == 0 and now.hour < 1:  # Sunday before 01:00
                return {'allowed': False, 'reason': '‡∏ï‡∏•‡∏≤‡∏î‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå'}
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Account Info
            account_info = mt5.account_info()
            if not account_info:
                return {'allowed': False, 'reason': '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÑ‡∏î‡πâ'}
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡∏£‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if not account_info.trade_allowed:
                return {'allowed': False, 'reason': '‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡πÑ‡∏°‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡∏£‡∏î'}
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÄ‡∏á‡∏¥‡∏ô‡∏û‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô)
            if account_info.margin_free <= 0:
                return {'allowed': False, 'reason': '‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ó‡∏£‡∏î'}
            
            return {'allowed': True, 'reason': '‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ'}
            
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î: {e}")
            return {'allowed': False, 'reason': f'‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {str(e)}'}
        
    def close_position(self, ticket: int) -> Optional[Dict]:
        """
        ‡∏õ‡∏¥‡∏î Position
        
        Args:
            ticket: ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç Position
            
        Returns:
            Dict: ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î Position ‡∏´‡∏£‡∏∑‡∏≠ None
        """
        if not self.check_connection_health():
            return None
            
        try:
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Position
            position = mt5.positions_get(ticket=ticket)
            if not position:
                logger.error(f"‡πÑ‡∏°‡πà‡∏û‡∏ö Position ticket {ticket}")
                return None
                
            pos = position[0]
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó Order ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏¥‡∏î Position
            if pos.type == mt5.POSITION_TYPE_BUY:
                order_type = mt5.ORDER_TYPE_SELL
                price = mt5.symbol_info_tick(pos.symbol).bid
            else:
                order_type = mt5.ORDER_TYPE_BUY
                price = mt5.symbol_info_tick(pos.symbol).ask
                
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö filling type ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
            filling_type = self._detect_filling_type(pos.symbol)
            
            # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• request
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": pos.symbol,
                "volume": pos.volume,
                "type": order_type,
                "position": ticket,
                "price": price,
                "comment": f"Close position {ticket}",
                "type_filling": filling_type,
            }
            
            # ‡∏õ‡∏¥‡∏î Position
            result = mt5.order_send(request)
            if result:
                return {
                    'retcode': result.retcode,
                    'deal': result.deal,
                    'order': result.order,
                    'volume': result.volume,
                    'price': result.price,
                    'comment': result.comment
                }
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î Position {ticket}: {e}")
            
        return None
        
    def _load_broker_symbols(self):
        """
        ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ XAUUSD
        """
        try:
            if not MT5_AVAILABLE:
                return
                
            # ‡∏î‡∏∂‡∏á‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            symbols = mt5.symbols_get()
            if symbols:
                gold_symbols = []
                for symbol in symbols:
                    symbol_name = symbol.name
                    self.broker_symbols[symbol_name] = {
                        'name': symbol_name,
                        'description': symbol.description,
                        'currency_base': symbol.currency_base,
                        'currency_profit': symbol.currency_profit,
                        'digits': symbol.digits,
                        'point': symbol.point,
                        'volume_min': symbol.volume_min,
                        'volume_max': symbol.volume_max,
                        'volume_step': symbol.volume_step,
                        'contract_size': symbol.trade_contract_size
                    }
                    
                    # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥
                    if any(gold in symbol_name.upper() for gold in ['XAU', 'GOLD']):
                        gold_symbols.append(symbol_name)
                        
                if gold_symbols:
                    logger.info(f"‡∏û‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥: {', '.join(gold_symbols)}")
                else:
                    logger.warning("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥‡πÉ‡∏ô‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ")
                    
        except Exception as e:
            logger.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå: {str(e)}")
            
    def find_symbol(self, base_symbol: str) -> Optional[str]:
        """
        ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö base_symbol ‡πÉ‡∏ô‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå
        
        Args:
            base_symbol: ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô ‡πÄ‡∏ä‡πà‡∏ô 'XAUUSD'
            
        Returns:
            str: ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏û‡∏ö‡πÉ‡∏ô‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå ‡∏´‡∏£‡∏∑‡∏≠ None
        """
        if not self.broker_symbols:
            return None
            
        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡∏ï‡∏£‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        if base_symbol in self.broker_symbols:
            return base_symbol
            
        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö partial match
        base_upper = base_symbol.upper()
        for symbol_name in self.broker_symbols.keys():
            if base_upper in symbol_name.upper():
                logger.info(f"‡∏û‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô: {base_symbol} -> {symbol_name}")
                return symbol_name
                
        # ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞
        if 'XAU' in base_upper or 'GOLD' in base_upper:
            for symbol_name in self.broker_symbols.keys():
                if any(gold in symbol_name.upper() for gold in ['XAU', 'GOLD']):
                    logger.info(f"‡∏û‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥: {base_symbol} -> {symbol_name}")
                    return symbol_name
                    
        logger.warning(f"‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {base_symbol} ‡πÉ‡∏ô‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå")
        return None
        
    def get_available_gold_symbols(self) -> List[str]:
        """
        ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÇ‡∏ö‡∏£‡∏Å‡πÄ‡∏Å‡∏≠‡∏£‡πå
        
        Returns:
            List[str]: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏≠‡∏á‡∏Ñ‡∏≥
        """
        gold_symbols = []
        for symbol_name in self.broker_symbols.keys():
            if any(gold in symbol_name.upper() for gold in ['XAU', 'GOLD']):
                gold_symbols.append(symbol_name)
        return gold_symbols
        
    def _detect_filling_type(self, symbol: str) -> int:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏à‡∏î‡∏à‡∏≥ filling type ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå
        
        Args:
            symbol: ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
            
        Returns:
            int: filling type ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
        """
        if symbol in self.filling_types:
            return self.filling_types[symbol]
            
        # ‡∏•‡∏¥‡∏™‡∏ï‡πå filling types ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏î‡∏™‡∏≠‡∏ö
        filling_types_to_test = [
            mt5.ORDER_FILLING_FOK,  # Fill or Kill
            mt5.ORDER_FILLING_IOC,  # Immediate or Cancel
            mt5.ORDER_FILLING_RETURN  # Return
        ]
        
        for filling_type in filling_types_to_test:
            try:
                # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á order ‡∏à‡∏≥‡∏•‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏à‡∏£‡∏¥‡∏á)
                symbol_info = mt5.symbol_info(symbol)
                if symbol_info:
                    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å filling type ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
                    self.filling_types[symbol] = filling_type
                    
                    filling_name = {
                        mt5.ORDER_FILLING_FOK: "FOK",
                        mt5.ORDER_FILLING_IOC: "IOC", 
                        mt5.ORDER_FILLING_RETURN: "RETURN"
                    }.get(filling_type, "UNKNOWN")
                    
                    logger.info(f"‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {symbol} ‡πÉ‡∏ä‡πâ filling type: {filling_name}")
                    return filling_type
                    
            except Exception:
                continue
                
        # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö ‡πÉ‡∏ä‡πâ FOK ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        self.filling_types[symbol] = mt5.ORDER_FILLING_FOK
        logger.warning(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö filling type ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {symbol} ‡πÉ‡∏ä‡πâ FOK ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô")
        return mt5.ORDER_FILLING_FOK

