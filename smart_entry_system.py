import MetaTrader5 as mt5
import numpy as np
from datetime import datetime, timedelta
from typing import List, Dict, Tuple, Optional, Any
import logging

logger = logging.getLogger(__name__)

class SmartEntrySystem:
    """üéØ ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà (Support/Resistance ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)"""
    
    def __init__(self, mt5_connection, zone_analyzer):
        self.mt5_connection = mt5_connection
        self.zone_analyzer = zone_analyzer
        self.symbol = None  # ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å main system
        
        # Entry Parameters (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô)
        self.support_buy_enabled = True      # ‡πÄ‡∏õ‡∏¥‡∏î Support entries (BUY ‡∏ó‡∏µ‡πà Support)
        self.resistance_sell_enabled = True  # ‡πÄ‡∏õ‡∏¥‡∏î Resistance entries (SELL ‡∏ó‡∏µ‡πà Resistance)
        
        # Enhanced Zone Selection Parameters - ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö Zone Strength ‡∏™‡∏π‡∏á
        self.profit_target_pips = 35  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏õ‡πá‡∏ô 35 pips (‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ)
        self.loss_threshold_pips = 30  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏õ‡πá‡∏ô 30 pips (‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ)
        self.recovery_zone_strength = 10  # ‡πÄ‡∏û‡∏¥‡πà‡∏° Zone strength ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Recovery
        self.min_zone_strength = 0.05  # Zone strength ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (0.05 = 5% ‡∏à‡∏≤‡∏Å 100)
        self.min_zone_touches = 1  # ‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô touches ‡πÄ‡∏õ‡πá‡∏ô 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á (Zone Strength ‡∏™‡∏π‡∏á = ‡πÅ‡∏ï‡∏∞‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡πá‡πÑ‡∏î‡πâ)
        self.min_algorithms_detected = 0  # ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î algorithms (Zone Strength ‡∏™‡∏π‡∏á = ‡∏û‡∏ö‡∏à‡∏≤‡∏Å‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡πá‡πÑ‡∏î‡πâ)
        
        # Enhanced Risk Management - ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û
        self.risk_percent_per_trade = 0.015  # ‡∏•‡∏î‡πÄ‡∏õ‡πá‡∏ô 1.5% ‡∏Ç‡∏≠‡∏á balance ‡∏ï‡πà‡∏≠ trade (‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏õ‡∏£‡∏¥‡∏°‡∏≤‡∏ì)
        self.max_daily_trades = 25  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô trade ‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô 25 (‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô)
        
        # Zone Quality Filters - ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö Zone Strength ‡∏™‡∏π‡∏á
        self.min_zone_distance_pips = 5  # ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÄ‡∏õ‡πá‡∏ô 5 pips (Zone Strength ‡∏™‡∏π‡∏á = ‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡πá‡πÑ‡∏î‡πâ)
        self.max_zone_distance_pips = 200  # ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 200 pips
        self.zone_cooldown_hours = 2  # ‡∏•‡∏î cooldown ‡πÄ‡∏õ‡πá‡∏ô 2 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á (Zone Strength ‡∏™‡∏π‡∏á = ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ö‡πà‡∏≠‡∏¢)
        self.min_time_between_trades = 30  # ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á trades ‡πÄ‡∏õ‡πá‡∏ô 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (Zone Strength ‡∏™‡∏π‡∏á = ‡πÄ‡∏ó‡∏£‡∏î‡πÑ‡∏î‡πâ‡∏ö‡πà‡∏≠‡∏¢)
        
        # Market Condition Filters - ‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î
        self.volatility_threshold = 0.8  # ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô (‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ = ‡∏ï‡∏•‡∏≤‡∏î‡∏ô‡∏¥‡πà‡∏á, ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ = ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô)
        self.trend_strength_threshold = 0.6  # ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
        self.volume_threshold = 1.2  # ‡πÄ‡∏Å‡∏ì‡∏ë‡πå Volume (‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ = Volume ‡∏ï‡πà‡∏≥, ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ = Volume ‡∏™‡∏π‡∏á)
        
        # Lot Size Management
        self.min_lot_size = 0.01
        self.max_lot_size = 1.0
        
        # Zone Tracking
        self.used_zones = {}  # {zone_key: {'timestamp': time, 'ticket': ticket}}
        self.daily_trade_count = 0
        self.last_reset_date = datetime.now().date()
        self.last_trade_time = None  # ‡πÄ‡∏ß‡∏•‡∏≤‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        
    def calculate_dynamic_profit_target(self, lot_size: float) -> float:
        """üéØ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡∏≤‡∏° lot size"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≤‡∏° pips ‡∏ï‡πà‡∏≠ lot
            profit_target = lot_size * self.profit_target_pips * 10  # XAUUSD pip value = 10
            return max(5.0, profit_target)  # ‡∏Å‡∏≥‡πÑ‡∏£‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ $5
        except Exception as e:
            logger.error(f"‚ùå Error calculating dynamic profit target: {e}")
            return 5.0  # fallback
    
    def calculate_dynamic_loss_threshold(self, lot_size: float) -> float:
        """‚ö†Ô∏è ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ï‡∏≤‡∏° lot size"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≤‡∏° pips ‡∏ï‡πà‡∏≠ lot
            loss_threshold = lot_size * self.loss_threshold_pips * 10  # XAUUSD pip value = 10
            return -max(5.0, loss_threshold)  # ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ -$5
        except Exception as e:
            logger.error(f"‚ùå Error calculating dynamic loss threshold: {e}")
            return -5.0  # fallback
    
    def calculate_dynamic_lot_size(self, zone_strength: float, zone: dict = None) -> float:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot size ‡∏ï‡∏≤‡∏° zone strength ‡πÅ‡∏•‡∏∞ balance"""
        try:
            # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏±‡∏ç‡∏ä‡∏µ
            account_info = self.mt5_connection.get_account_info()
            if not account_info:
                return self.min_lot_size
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ account_info ‡πÄ‡∏õ‡πá‡∏ô dict ‡∏´‡∏£‡∏∑‡∏≠ object
            if isinstance(account_info, dict):
                balance = account_info.get('balance', 1000.0)
            else:
                balance = getattr(account_info, 'balance', 1000.0)
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot size ‡∏ï‡∏≤‡∏° % ‡∏Ç‡∏≠‡∏á balance
            risk_amount = balance * self.risk_percent_per_trade
            
            # ‡∏õ‡∏£‡∏±‡∏ö pip value ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö XAUUSD (1 lot = 100 oz, pip value = 100)
            pip_value = 100  # XAUUSD pip value
            base_lot_size = risk_amount / (self.profit_target_pips * pip_value)
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° zone strength ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö XAUUSD)
            # ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏ö‡∏ö‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡∏ä‡πà‡∏ß‡∏á
            if zone_strength >= 90:
                # Zone ‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏°‡∏≤‡∏Å (90-100): ‡πÉ‡∏ä‡πâ lot ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                final_multiplier = 1.2 + (zone_strength - 90) * 0.02  # 1.2-1.4
            elif zone_strength >= 80:
                # Zone ‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á (80-89): ‡πÉ‡∏ä‡πâ lot ‡∏°‡∏≤‡∏Å
                final_multiplier = 1.0 + (zone_strength - 80) * 0.02  # 1.0-1.2
            elif zone_strength >= 70:
                # Zone ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (70-79): ‡πÉ‡∏ä‡πâ lot ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
                final_multiplier = 0.8 + (zone_strength - 70) * 0.02  # 0.8-1.0
            elif zone_strength >= 60:
                # Zone ‡∏≠‡πà‡∏≠‡∏ô (60-69): ‡πÉ‡∏ä‡πâ lot ‡∏ô‡πâ‡∏≠‡∏¢
                final_multiplier = 0.6 + (zone_strength - 60) * 0.02  # 0.6-0.8
            elif zone_strength >= 50:
                # Zone ‡∏≠‡πà‡∏≠‡∏ô‡∏°‡∏≤‡∏Å (50-59): ‡πÉ‡∏ä‡πâ lot ‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å
                final_multiplier = 0.4 + (zone_strength - 50) * 0.02  # 0.4-0.6
            else:
                # Zone ‡∏≠‡πà‡∏≠‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (<50): ‡πÉ‡∏ä‡πâ lot ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
                final_multiplier = 0.3
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏ï‡∏≤‡∏°‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏≠‡∏∑‡πà‡∏ô‡πÜ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ zone data)
            additional_multiplier = 1.0
            
            if zone:
                # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô touches ‡∏Ç‡∏≠‡∏á zone
                touches = zone.get('touches', 1)
                if touches >= 5:
                    additional_multiplier *= 1.3  # Zone ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏∞‡∏ö‡πà‡∏≠‡∏¢ = ‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.2)
                elif touches >= 3:
                    additional_multiplier *= 1.15  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.1
                elif touches <= 1:
                    additional_multiplier *= 0.9  # Zone ‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏∞‡∏ô‡πâ‡∏≠‡∏¢ = ‡∏≠‡πà‡∏≠‡∏ô (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 0.8)
                
                # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô algorithms ‡∏ó‡∏µ‡πà‡∏û‡∏ö zone ‡∏ô‡∏µ‡πâ
                algorithms_used = zone.get('algorithms_used', [])
                if isinstance(algorithms_used, list) and len(algorithms_used) >= 3:
                    additional_multiplier *= 1.25  # Zone ‡∏ó‡∏µ‡πà‡∏û‡∏ö‡∏à‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ = ‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.15)
                elif len(algorithms_used) >= 2:
                    additional_multiplier *= 1.1  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.05
                
                # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° zone count (zones ‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ô)
                zone_count = zone.get('zone_count', 1)
                if zone_count >= 3:
                    additional_multiplier *= 1.2  # Zone ‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß = ‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.1)
                
                # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° market condition (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)
                market_condition = zone.get('market_condition', 'normal')
                if market_condition == 'trending':
                    additional_multiplier *= 1.2  # ‡∏ï‡∏•‡∏≤‡∏î trending = ‡πÉ‡∏ä‡πâ lot ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.1)
                elif market_condition == 'sideways':
                    additional_multiplier *= 1.0  # ‡∏ï‡∏•‡∏≤‡∏î sideways = ‡πÉ‡∏ä‡πâ lot ‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 0.9)
                elif market_condition == 'volatile':
                    additional_multiplier *= 0.9  # ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô = ‡πÉ‡∏ä‡πâ lot ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 0.8)
                
                # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å current price
                current_price = zone.get('current_price', 0)
                zone_price = zone.get('price', 0)
                if current_price > 0 and zone_price > 0:
                    distance_pips = abs(current_price - zone_price) * 10000  # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô pips
                    if distance_pips <= 10:
                        additional_multiplier *= 1.3  # Zone ‡πÉ‡∏Å‡∏•‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô = ‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.2)
                    elif distance_pips <= 20:
                        additional_multiplier *= 1.15  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1.1
                    elif distance_pips >= 50:
                        additional_multiplier *= 1.0  # Zone ‡πÑ‡∏Å‡∏•‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô = ‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 0.9)
            
            final_lot_size = base_lot_size * final_multiplier * additional_multiplier
            
            # Debug log
            logger.info(f"üìä [LOT CALCULATION] Balance: ${balance:.2f}, Risk: {self.risk_percent_per_trade*100:.1f}%")
            logger.info(f"üìä [LOT CALCULATION] Risk Amount: ${risk_amount:.2f}, Pip Value: {pip_value}")
            logger.info(f"üìä [LOT CALCULATION] Base Lot: {base_lot_size:.4f}, Zone Strength: {zone_strength:.1f}")
            logger.info(f"üìä [LOT CALCULATION] Strength Multiplier: {final_multiplier:.3f}")
            
            if zone:
                touches = zone.get('touches', 1)
                algorithms_used = zone.get('algorithms_used', [])
                zone_count = zone.get('zone_count', 1)
                logger.info(f"üìä [LOT CALCULATION] Touches: {touches}, Algorithms: {len(algorithms_used)}, Zone Count: {zone_count}")
            else:
                logger.info(f"üìä [LOT CALCULATION] No zone data available")
            
            logger.info(f"üìä [LOT CALCULATION] Additional Multiplier: {additional_multiplier:.3f}")
            logger.info(f"üìä [LOT CALCULATION] Final Lot: {final_lot_size:.4f}")
            
            # ‡∏à‡∏≥‡∏Å‡∏±‡∏î lot size
            final_lot_size = max(self.min_lot_size, min(self.max_lot_size, final_lot_size))
            logger.info(f"üìä [LOT CALCULATION] Final Lot Size: {final_lot_size:.4f}")
            return final_lot_size
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating dynamic lot size: {e}")
            return self.min_lot_size  # fallback
    
    def calculate_pivot_point(self, current_price: float, zones: Dict[str, List[Dict]]) -> float:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Pivot Point ‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÅ‡∏•‡∏∞ zones"""
        try:
            support_zones = zones.get('support', [])
            resistance_zones = zones.get('resistance', [])
            
            logger.info(f"üîç [PIVOT] Support zones: {len(support_zones)}, Resistance zones: {len(resistance_zones)}")
            
            if not support_zones or not resistance_zones:
                logger.warning(f"üö´ [PIVOT] Missing zones - using current price: {current_price}")
                return current_price
            
            # ‡∏´‡∏≤ Support ‡πÅ‡∏•‡∏∞ Resistance ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            nearest_support = min(support_zones, key=lambda x: abs(x['price'] - current_price))
            nearest_resistance = min(resistance_zones, key=lambda x: abs(x['price'] - current_price))
            
            logger.info(f"üîç [PIVOT] Nearest Support: {nearest_support['price']:.2f}, Resistance: {nearest_resistance['price']:.2f}")
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Pivot Point
            pivot_point = (current_price + nearest_support['price'] + nearest_resistance['price']) / 3
            
            logger.info(f"üîç [PIVOT] Calculated Pivot Point: {pivot_point:.2f}")
            return pivot_point
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating pivot point: {e}")
            return current_price  # fallback
    
    def select_zone_by_pivot_and_strength(self, current_price: float, zones: Dict[str, List[Dict]]) -> Tuple[Optional[str], Optional[Dict]]:
        """üéØ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Zone ‡πÅ‡∏ö‡∏ö Enhanced - ‡∏Å‡∏£‡∏≠‡∏á Zone ‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Pivot Point
            pivot_point = self.calculate_pivot_point(current_price, zones)
            support_zones = zones.get('support', [])
            resistance_zones = zones.get('resistance', [])
            
            logger.info(f"üîç [ENHANCED ZONE SELECTION] Price: {current_price:.5f}, Pivot: {pivot_point:.5f}")
            logger.info(f"üîç [ENHANCED ZONE SELECTION] Raw Zones: {len(support_zones)} support, {len(resistance_zones)} resistance")
            
            if not support_zones or not resistance_zones:
                logger.warning("üö´ [ENHANCED ZONE SELECTION] No support or resistance zones available")
                return None, None
            
            # üéØ Enhanced Zone Filtering - ‡∏Å‡∏£‡∏≠‡∏á Zone ‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
            filtered_supports = self._filter_high_quality_zones(support_zones, current_price, 'support')
            filtered_resistances = self._filter_high_quality_zones(resistance_zones, current_price, 'resistance')
            
            logger.info(f"üîç [ENHANCED ZONE SELECTION] Filtered Zones: {len(filtered_supports)} support, {len(filtered_resistances)} resistance")
            
            if not filtered_supports and not filtered_resistances:
                logger.warning("üö´ [ENHANCED ZONE SELECTION] No high-quality zones found after filtering")
                logger.info("üîÑ [FALLBACK] Trying relaxed criteria...")
                
                # Fallback: ‡∏•‡∏î‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ Zone
                relaxed_supports = self._filter_relaxed_zones(support_zones, current_price, 'support')
                relaxed_resistances = self._filter_relaxed_zones(resistance_zones, current_price, 'resistance')
                
                if not relaxed_supports and not relaxed_resistances:
                    logger.warning("üö´ [FALLBACK] No zones found even with relaxed criteria")
                    return None, None
                
                # ‡πÉ‡∏ä‡πâ relaxed zones
                filtered_supports = relaxed_supports
                filtered_resistances = relaxed_resistances
                logger.info(f"üîÑ [FALLBACK] Using relaxed criteria: {len(filtered_supports)} support, {len(filtered_resistances)} resistance")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á support ‡πÅ‡∏•‡∏∞ resistance ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            min_distance_pips = 30.0  # ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÄ‡∏õ‡πá‡∏ô 30 pips (‡πÉ‡∏´‡πâ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô)
            if filtered_supports and filtered_resistances:
                closest_support_price = min(filtered_supports, key=lambda x: abs(x['price'] - current_price))['price']
                closest_resistance_price = min(filtered_resistances, key=lambda x: abs(x['price'] - current_price))['price']
                distance_between_zones = abs(closest_support_price - closest_resistance_price) * 10000  # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô pips
                
                logger.info(f"üîç [ENHANCED ZONE SELECTION] Distance between closest zones: {distance_between_zones:.1f} pips")
                
                if distance_between_zones < min_distance_pips:
                    logger.warning(f"üö´ [ENHANCED ZONE SELECTION] Zones too close: {distance_between_zones:.1f} pips < {min_distance_pips} pips")
                    return None, None
            
            # üéØ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Zone ‡∏ï‡∏≤‡∏° Pivot Point + Quality Score
            if current_price < pivot_point:
                # ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ Pivot ‚Üí ‡∏´‡∏≤ Support ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                if filtered_supports:
                    best_support = self._select_best_zone(filtered_supports, current_price)
                    if best_support:
                        logger.info(f"‚úÖ [ENHANCED ZONE SELECTION] Selected SUPPORT: {best_support['price']:.5f} (strength: {best_support['strength']:.1f}, touches: {best_support.get('touches', 0)})")
                        return 'support', best_support
                logger.warning("üö´ [ENHANCED ZONE SELECTION] No valid SUPPORT zones found")
            else:
                # ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ Pivot ‚Üí ‡∏´‡∏≤ Resistance ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                if filtered_resistances:
                    best_resistance = self._select_best_zone(filtered_resistances, current_price)
                    if best_resistance:
                        logger.info(f"‚úÖ [ENHANCED ZONE SELECTION] Selected RESISTANCE: {best_resistance['price']:.5f} (strength: {best_resistance['strength']:.1f}, touches: {best_resistance.get('touches', 0)})")
                        return 'resistance', best_resistance
                logger.warning("üö´ [ENHANCED ZONE SELECTION] No valid RESISTANCE zones found")
            
            return None, None
            
        except Exception as e:
            logger.error(f"‚ùå Error in enhanced zone selection: {e}")
            return None, None
    
    def _filter_high_quality_zones(self, zones: List[Dict], current_price: float, zone_type: str) -> List[Dict]:
        """üéØ ‡∏Å‡∏£‡∏≠‡∏á Zone ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢ - ‡πÄ‡∏ô‡πâ‡∏ô Zone Strength ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å"""
        try:
            filtered_zones = []
            
            for zone in zones:
                zone_price = zone.get('price', 0)
                zone_strength_raw = zone.get('strength', 0)
                touches = zone.get('touches', 0)
                algorithms_used = zone.get('algorithms_used', [])
                distance_pips = abs(zone_price - current_price) * 10000
                
                # ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏´‡∏•‡∏±‡∏Å: Zone Strength ‡∏ï‡πâ‡∏≠‡∏á‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå (‡πÅ‡∏õ‡∏•‡∏á 0-100 ‡πÄ‡∏õ‡πá‡∏ô 0-1)
                zone_strength_normalized = zone_strength_raw / 100.0
                if zone_strength_normalized < self.min_zone_strength:
                    continue
                
                # ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏£‡∏≠‡∏á: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
                if touches < self.min_zone_touches:
                    continue
                
                if isinstance(algorithms_used, list) and len(algorithms_used) < self.min_algorithms_detected:
                    continue
                
                if distance_pips < self.min_zone_distance_pips or distance_pips > self.max_zone_distance_pips:
                    continue
                
                # ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢: Cooldown ‡πÅ‡∏•‡∏∞ Validity
                if self._is_zone_on_cooldown(zone):
                    continue
                
                if not self._is_valid_entry_zone(zone, current_price):
                    continue
                
                # Zone ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
                filtered_zones.append(zone)
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° Quality Score (Strength + Touches + Algorithms)
            filtered_zones.sort(key=lambda x: self._calculate_zone_quality_score(x), reverse=True)
            
            logger.info(f"üîç [ZONE FILTERING] {zone_type.upper()}: {len(zones)} ‚Üí {len(filtered_zones)} zones after filtering")
            if filtered_zones:
                best_zone = filtered_zones[0]
                raw_strength = best_zone.get('strength', 0)
                normalized_strength = raw_strength / 100.0
                logger.info(f"üîç [ZONE FILTERING] Best zone: {best_zone['price']:.5f} (Raw: {raw_strength:.1f}, Normalized: {normalized_strength:.3f})")
            
            return filtered_zones
            
        except Exception as e:
            logger.error(f"‚ùå Error filtering high-quality zones: {e}")
            return []
    
    def _filter_relaxed_zones(self, zones: List[Dict], current_price: float, zone_type: str) -> List[Dict]:
        """üîÑ ‡∏Å‡∏£‡∏≠‡∏á Zone ‡πÅ‡∏ö‡∏ö Relaxed - ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏ú‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏ô"""
        try:
            filtered_zones = []
            
            for zone in zones:
                # 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Zone Strength (‡∏•‡∏î‡πÄ‡∏Å‡∏ì‡∏ë‡πå - ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å 0-100 ‡πÄ‡∏õ‡πá‡∏ô 0-1)
                zone_strength_raw = zone.get('strength', 0)
                zone_strength_normalized = zone_strength_raw / 100.0  # ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å 0-100 ‡πÄ‡∏õ‡πá‡∏ô 0-1
                if zone_strength_normalized < 0.03:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 0.05 ‡πÄ‡∏õ‡πá‡∏ô 0.03
                    continue
                
                # 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Touches (‡∏•‡∏î‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
                touches = zone.get('touches', 0)
                if touches < 1:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 2 ‡πÄ‡∏õ‡πá‡∏ô 1
                    continue
                
                # 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Algorithms (‡∏•‡∏î‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
                algorithms_used = zone.get('algorithms_used', [])
                if isinstance(algorithms_used, list) and len(algorithms_used) < 1:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 2 ‡πÄ‡∏õ‡πá‡∏ô 1
                    continue
                
                # 4. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
                distance_pips = abs(zone['price'] - current_price) * 10000
                if distance_pips < 10 or distance_pips > 300:  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 20-200 ‡πÄ‡∏õ‡πá‡∏ô 10-300
                    continue
                
                # 5. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Zone ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á (‡∏•‡∏î Cooldown)
                if self._is_zone_on_relaxed_cooldown(zone):
                    continue
                
                # 6. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Zone Validity (‡∏•‡∏î‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
                if self._is_valid_entry_zone_relaxed(zone, current_price):
                    filtered_zones.append(zone)
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° Quality Score (Strength + Touches + Algorithms)
            filtered_zones.sort(key=lambda x: self._calculate_zone_quality_score(x), reverse=True)
            
            logger.info(f"üîÑ [RELAXED FILTERING] {zone_type.upper()}: {len(zones)} ‚Üí {len(filtered_zones)} zones after relaxed filtering")
            
            return filtered_zones
            
        except Exception as e:
            logger.error(f"‚ùå Error filtering relaxed zones: {e}")
            return []
    
    def _is_zone_on_relaxed_cooldown(self, zone: Dict) -> bool:
        """üïí ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Zone Cooldown ‡πÅ‡∏ö‡∏ö Relaxed"""
        try:
            zone_key = self._generate_zone_key(zone)
            
            if zone_key in self.used_zones:
                last_used = self.used_zones[zone_key]['timestamp']
                time_since_used = datetime.now() - last_used
                
                # ‡∏•‡∏î cooldown ‡πÄ‡∏õ‡πá‡∏ô 2 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
                relaxed_cooldown_hours = 2
                if time_since_used.total_seconds() < (relaxed_cooldown_hours * 3600):
                    logger.debug(f"üïí Zone {zone['price']} on relaxed cooldown: {time_since_used.total_seconds()/3600:.1f}h < {relaxed_cooldown_hours}h")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Error checking relaxed zone cooldown: {e}")
            return False
    
    def _is_valid_entry_zone_relaxed(self, zone: Dict, current_price: float) -> bool:
        """‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Zone ‡πÅ‡∏ö‡∏ö Relaxed"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏•‡∏î‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
            min_distance_from_existing = 15.0  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 35 ‡πÄ‡∏õ‡πá‡∏ô 15 pips
            if hasattr(self, 'order_manager') and self.order_manager and self.symbol:
                try:
                    existing_positions = self.order_manager.get_positions_by_symbol(self.symbol)
                    for position in existing_positions:
                        if hasattr(position, 'price') and position.price > 0:
                            distance_from_existing = abs(zone['price'] - position.price) * 10000
                            if distance_from_existing < min_distance_from_existing:
                                logger.debug(f"üö´ Zone {zone['price']} too close to existing position: {distance_from_existing:.1f} pips")
                                return False
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Could not check existing positions: {e}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error validating relaxed entry zone: {e}")
            return False
    
    def _calculate_zone_quality_score(self, zone: Dict) -> float:
        """üéØ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Quality Score ‡∏Ç‡∏≠‡∏á Zone"""
        try:
            strength_raw = zone.get('strength', 0)
            strength_normalized = strength_raw / 100.0  # ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏≤‡∏Å 0-100 ‡πÄ‡∏õ‡πá‡∏ô 0-1
            touches = zone.get('touches', 0)
            algorithms_used = zone.get('algorithms_used', [])
            zone_count = zone.get('zone_count', 1)
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Score
            score = 0.0
            
            # Strength Score (40%) - ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ normalized
            score += strength_normalized * 40
            
            # Touches Score (30%)
            score += min(touches, 10) * 3  # ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 10 touches
            
            # Algorithms Score (20%)
            score += len(algorithms_used) * 2
            
            # Zone Count Score (10%)
            score += min(zone_count, 5) * 2  # ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 5 zones
            
            return score
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating zone quality score: {e}")
            return 0.0
    
    def _select_best_zone(self, zones: List[Dict], current_price: float) -> Optional[Dict]:
        """üéØ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Zone ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Zone ‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß"""
        try:
            if not zones:
                return None
            
            # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Zone ‡∏ó‡∏µ‡πà‡∏°‡∏µ Quality Score ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏Å‡∏•‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
            best_zone = None
            best_score = -1
            
            for zone in zones[:5]:  # ‡∏î‡∏π‡πÅ‡∏Ñ‡πà 5 Zone ‡πÅ‡∏£‡∏Å (‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° Quality Score ‡πÅ‡∏•‡πâ‡∏ß)
                quality_score = self._calculate_zone_quality_score(zone)
                distance_pips = abs(zone['price'] - current_price) * 10000
                
                # ‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Zone ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏Å‡∏•‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                if distance_pips <= 80:  # Zone ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ (‚â§80 pips)
                    quality_score *= 1.2
                elif distance_pips <= 120:  # Zone ‡∏ó‡∏µ‡πà‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á (‚â§120 pips)
                    quality_score *= 1.1
                
                if quality_score > best_score:
                    best_score = quality_score
                    best_zone = zone
            
            return best_zone
            
        except Exception as e:
            logger.error(f"‚ùå Error selecting best zone: {e}")
            return None
    
    def _is_zone_on_cooldown(self, zone: Dict) -> bool:
        """üïí ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Zone ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á Cooldown ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà - ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Zone Strength"""
        try:
            zone_key = self._generate_zone_key(zone)
            
            if zone_key in self.used_zones:
                last_used = self.used_zones[zone_key]['timestamp']
                time_since_used = datetime.now() - last_used
                
                # ‡∏õ‡∏£‡∏±‡∏ö cooldown ‡∏ï‡∏≤‡∏° Zone Strength
                zone_strength_raw = zone.get('strength', 0)
                if zone_strength_raw > 70:  # Zone Strength ‡∏™‡∏π‡∏á‡∏°‡∏≤‡∏Å = cooldown ‡∏™‡∏±‡πâ‡∏ô
                    cooldown_hours = 1
                elif zone_strength_raw > 50:  # Zone Strength ‡∏™‡∏π‡∏á = cooldown ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
                    cooldown_hours = 2
                else:  # Zone Strength ‡∏õ‡∏Å‡∏ï‡∏¥ = cooldown ‡∏õ‡∏Å‡∏ï‡∏¥
                    cooldown_hours = self.zone_cooldown_hours
                
                if time_since_used.total_seconds() < (cooldown_hours * 3600):
                    logger.debug(f"üïí Zone {zone['price']} on cooldown: {time_since_used.total_seconds()/3600:.1f}h < {cooldown_hours}h")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Error checking zone cooldown: {e}")
            return False
    
    def _analyze_market_conditions(self, current_price: float, zones: Dict[str, List[Dict]]) -> Dict[str, Any]:
        """üìä ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ"""
        try:
            market_conditions = {
                'volatility': 'normal',
                'trend': 'sideways',
                'volume': 'normal',
                'entry_recommendation': 'neutral'
            }
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏à‡∏≤‡∏Å Support/Resistance
            support_zones = zones.get('support', [])
            resistance_zones = zones.get('resistance', [])
            
            if support_zones and resistance_zones:
                # ‡∏´‡∏≤ Support ‡πÅ‡∏•‡∏∞ Resistance ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                closest_support = min(support_zones, key=lambda x: abs(x['price'] - current_price))
                closest_resistance = min(resistance_zones, key=lambda x: abs(x['price'] - current_price))
                
                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Support/Resistance
                range_size = abs(closest_resistance['price'] - closest_support['price']) * 10000  # pips
                
                # ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô)
                if range_size > 300:  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡πÄ‡∏õ‡πá‡∏ô 300 pips = ‡∏ï‡∏•‡∏≤‡∏î‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô
                    market_conditions['volatility'] = 'high'
                elif range_size < 50:  # ‡∏•‡∏î‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡πÄ‡∏õ‡πá‡∏ô 50 pips = ‡∏ï‡∏•‡∏≤‡∏î‡∏ô‡∏¥‡πà‡∏á
                    market_conditions['volatility'] = 'low'
                
                # ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
                pivot_point = self.calculate_pivot_point(current_price, zones)
                if current_price > pivot_point * 1.002:  # ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ Pivot ‡∏°‡∏≤‡∏Å = Uptrend
                    market_conditions['trend'] = 'uptrend'
                elif current_price < pivot_point * 0.998:  # ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ Pivot ‡∏°‡∏≤‡∏Å = Downtrend
                    market_conditions['trend'] = 'downtrend'
                
                # ‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡∏°‡πà - ‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á = ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ)
                if market_conditions['volatility'] == 'high':
                    market_conditions['entry_recommendation'] = 'high_volatility'  # ‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á = ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ
                elif market_conditions['volatility'] == 'low' and market_conditions['trend'] == 'sideways':
                    market_conditions['entry_recommendation'] = 'favorable'  # ‡∏ï‡∏•‡∏≤‡∏î‡∏ô‡∏¥‡πà‡∏á = ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡πÑ‡∏î‡πâ‡∏î‡∏µ
                elif market_conditions['trend'] in ['uptrend', 'downtrend']:
                    market_conditions['entry_recommendation'] = 'trend_following'  # ‡∏ï‡∏•‡∏≤‡∏î‡∏°‡∏µ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå = ‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
            
            logger.info(f"üìä [MARKET CONDITIONS] Volatility: {market_conditions['volatility']}, Trend: {market_conditions['trend']}, Recommendation: {market_conditions['entry_recommendation']}")
            
            return market_conditions
            
        except Exception as e:
            logger.error(f"‚ùå Error analyzing market conditions: {e}")
            return {'volatility': 'normal', 'trend': 'sideways', 'volume': 'normal', 'entry_recommendation': 'neutral'}
    
    def _should_enter_based_on_market_conditions(self, market_conditions: Dict[str, Any], zone_type: str) -> bool:
        """üéØ ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏Ñ‡∏ß‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡∏ï‡∏•‡∏≤‡∏î"""
        try:
            recommendation = market_conditions.get('entry_recommendation', 'neutral')
            volatility = market_conditions.get('volatility', 'normal')
            trend = market_conditions.get('trend', 'sideways')
            
            # ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á (High Volatility) - ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ
            if recommendation == 'high_volatility':
                logger.info("üöÄ [MARKET FILTER] High volatility detected - GREAT opportunity for profit taking!")
                logger.info("üí° [MARKET FILTER] Market moving = More chances to close positions at profit")
                return True
            
            # ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡∏•‡∏≤‡∏î‡∏ô‡∏¥‡πà‡∏á‡∏°‡∏≤‡∏Å - ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ
            if recommendation == 'favorable':
                logger.info("‚úÖ [MARKET FILTER] Market conditions favorable for entry")
                return True
            
            # ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡∏•‡∏≤‡∏î‡∏°‡∏µ‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
            if recommendation == 'trend_following':
                if trend == 'uptrend' and zone_type == 'support':
                    logger.info("‚úÖ [MARKET FILTER] Uptrend + Support zone - good for BUY")
                    return True
                elif trend == 'downtrend' and zone_type == 'resistance':
                    logger.info("‚úÖ [MARKET FILTER] Downtrend + Resistance zone - good for SELL")
                    return True
                else:
                    logger.info(f"‚úÖ [MARKET FILTER] Trend following - allowing entry (trend: {trend}, zone: {zone_type})")
                    return True  # ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡πÄ‡∏ó‡∏£‡∏ô‡∏î‡πå
            
            # ‡∏Å‡∏£‡∏ì‡∏µ‡∏õ‡∏Å‡∏ï‡∏¥ - ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ
            if recommendation == 'neutral':
                logger.info("‚úÖ [MARKET FILTER] Normal market conditions - allowing entry")
                return True
            
            # ‡∏Å‡∏£‡∏ì‡∏µ‡∏≠‡∏∑‡πà‡∏ô‡πÜ - ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ (‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Å)
            logger.info("‚úÖ [MARKET FILTER] Allowing entry - no blocking conditions")
            return True
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error checking market conditions for entry: {e}")
            return True  # Default to allowing entry if error
    
    def _is_valid_entry_zone(self, zone: Dict, current_price: float) -> bool:
        """‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Zone ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà - ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢ ‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏≠‡∏∑‡πà‡∏ô"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πâ Zone ‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á (Cooldown)
            zone_key = self._generate_zone_key(zone)
            if zone_key in self.used_zones:
                logger.debug(f"üö´ Zone {zone['price']} already used")
                return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Zone Strength)
            zone_strength_raw = zone.get('strength', 0)
            if zone_strength_raw > 60:  # Zone Strength ‡∏™‡∏π‡∏á = ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á
                min_distance_from_existing = 15.0
            elif zone_strength_raw > 40:  # Zone Strength ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
                min_distance_from_existing = 25.0
            else:  # Zone Strength ‡∏ï‡πà‡∏≥ = ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
                min_distance_from_existing = 35.0
                
            if hasattr(self, 'order_manager') and self.order_manager and self.symbol:
                try:
                    existing_positions = self.order_manager.get_positions_by_symbol(self.symbol)
                    for position in existing_positions:
                        if hasattr(position, 'price') and position.price > 0:
                            distance_from_existing = abs(zone['price'] - position.price) * 10000  # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô pips
                            if distance_from_existing < min_distance_from_existing:
                                logger.debug(f"üö´ Zone {zone['price']} too close to existing position: {distance_from_existing:.1f} pips < {min_distance_from_existing} pips")
                                return False
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è Could not check existing positions: {e}")
                    # ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ error ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error validating entry zone: {e}")
            return False
    
    def _generate_zone_key(self, zone: Dict) -> str:
        """üîë ‡∏™‡∏£‡πâ‡∏≤‡∏á key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Zone"""
        try:
            return f"{zone['price']:.5f}_{zone.get('strength', 0)}"
        except Exception as e:
            logger.error(f"‚ùå Error generating zone key: {e}")
            return f"{zone.get('price', 0):.5f}_0"
    
    def _reset_daily_counter(self):
        """üîÑ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï daily counter"""
        try:
            current_date = datetime.now().date()
            if current_date != self.last_reset_date:
                self.daily_trade_count = 0
                self.last_reset_date = current_date
        except Exception as e:
            logger.error(f"‚ùå Error resetting daily counter: {e}")
    
    def _cleanup_used_zones(self):
        """üßπ ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î used_zones"""
        try:
            current_time = datetime.now()
            expired_zones = []
            
            for zone_key, zone_data in self.used_zones.items():
                # ‡∏•‡∏ö zones ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô cooldown period
                cooldown_hours = self.zone_cooldown_hours + 12  # ‡πÄ‡∏û‡∏¥‡πà‡∏° 12 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
                if current_time - zone_data['timestamp'] > timedelta(hours=cooldown_hours):
                    expired_zones.append(zone_key)
            
            for zone_key in expired_zones:
                del self.used_zones[zone_key]
                
            if expired_zones:
                logger.info(f"üßπ [ZONE CLEANUP] Removed {len(expired_zones)} expired zones from cooldown")
                
        except Exception as e:
            logger.error(f"‚ùå Error cleaning up used zones: {e}")
    
    def analyze_entry_opportunity(self, symbol: str, current_price: float, zones: Dict[str, List[Dict]], 
                                existing_positions: List = None) -> Optional[Dict]:
        """üîç ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà (Support/Resistance ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)"""
        try:
            logger.info(f"üîç [SMART ENTRY] Starting entry analysis for {symbol} at {current_price:.5f}")
            logger.info(f"üîç [SMART ENTRY] Zones received: {len(zones.get('support', []))} support, {len(zones.get('resistance', []))} resistance")
            self.symbol = symbol  # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ symbol ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
            # ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï daily counter
            self._reset_daily_counter()
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö daily limit
            if self.daily_trade_count >= self.max_daily_trades:
                logger.debug("üö´ Daily trade limit reached")
                return None
            
            # ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î used_zones (‡∏•‡∏ö zones ‡πÄ‡∏Å‡πà‡∏≤)
            self._cleanup_used_zones()
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÅ‡∏•‡∏∞‡∏Ç‡∏≤‡∏¢ (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)
            if hasattr(self, 'last_trade_time') and self.last_trade_time is not None:
                time_since_last_trade = (datetime.now() - self.last_trade_time).total_seconds()
                if time_since_last_trade < self.min_time_between_trades:
                    logger.debug(f"üö´ Too soon since last trade: {time_since_last_trade:.1f}s < {self.min_time_between_trades}s")
                    return None
            
            # üéØ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Zone ‡∏ï‡∏≤‡∏° Pivot Point + Zone Strength (‡∏ß‡∏¥‡∏ò‡∏µ C)
            zone_type, selected_zone = self.select_zone_by_pivot_and_strength(current_price, zones)
            
            if not zone_type or not selected_zone:
                # Log all available zones for debugging
                support_zones = zones.get('support', [])
                resistance_zones = zones.get('resistance', [])
                
                logger.warning("=" * 80)
                logger.warning("üö´ [SMART ENTRY] NO SUITABLE ZONE FOUND FOR ENTRY")
                logger.warning("=" * 80)
                logger.warning(f"üìä [SMART ENTRY] Current Price: {current_price:.5f}")
                logger.warning(f"üìà [SMART ENTRY] Available Support Zones: {len(support_zones)}")
                for i, zone in enumerate(support_zones[:5], 1):
                    distance = abs(zone['price'] - current_price)
                    logger.warning(f"      {i}. {zone['price']:.5f} (Strength: {zone['strength']:.1f}, Distance: {distance:.5f})")
                
                logger.warning(f"üìâ [SMART ENTRY] Available Resistance Zones: {len(resistance_zones)}")
                for i, zone in enumerate(resistance_zones[:5], 1):
                    distance = abs(zone['price'] - current_price)
                    logger.warning(f"      {i}. {zone['price']:.5f} (Strength: {zone['strength']:.1f}, Distance: {distance:.5f})")
                
                logger.warning(f"üîß [SMART ENTRY] Min Zone Strength: {self.min_zone_strength} (normalized from 0-100 scale)")
                logger.warning("üîß [SMART ENTRY] Zone Strength Scale: Raw values 0-100, Normalized to 0-1 for comparison")
                logger.warning("üîß [SMART ENTRY] Example: Zone with strength 67.8 = 0.678 normalized")
                return None
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Zone ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if not self._is_valid_entry_zone(selected_zone, current_price):
                logger.warning(f"üö´ Zone {selected_zone['price']} is not valid for entry")
                logger.warning(f"   Current Price: {current_price:.2f}, Zone Price: {selected_zone['price']:.2f}")
                return None
            
            # üéØ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Market Conditions ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ
            market_conditions = self._analyze_market_conditions(current_price, zones)
            if not self._should_enter_based_on_market_conditions(market_conditions, zone_type):
                logger.warning(f"üö´ [MARKET FILTER] Entry blocked by market conditions")
                logger.warning(f"   Market: {market_conditions.get('volatility', 'unknown')} volatility, {market_conditions.get('trend', 'unknown')} trend")
                return None
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot size ‡πÅ‡∏ö‡∏ö dynamic (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Market Conditions)
            lot_size = self.calculate_dynamic_lot_size(selected_zone['strength'], selected_zone)
            
            # ‡∏õ‡∏£‡∏±‡∏ö lot size ‡∏ï‡∏≤‡∏° Market Conditions (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡∏°‡πà - ‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á = ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ)
            if market_conditions.get('entry_recommendation') == 'high_volatility':
                lot_size *= 1.3  # ‡πÄ‡∏û‡∏¥‡πà‡∏° lot size ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á (‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ)
                logger.info(f"üìä [LOT ADJUSTMENT] High volatility - increased lot size by 30% (great opportunity!)")
            elif market_conditions.get('entry_recommendation') == 'favorable':
                lot_size *= 1.2  # ‡πÄ‡∏û‡∏¥‡πà‡∏° lot size ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡∏î‡∏µ
                logger.info(f"üìä [LOT ADJUSTMENT] Favorable conditions - increased lot size by 20%")
            elif market_conditions.get('volatility') == 'low':
                lot_size *= 0.9  # ‡∏•‡∏î lot size ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ô‡∏¥‡πà‡∏á
                logger.info(f"üìä [LOT ADJUSTMENT] Low volatility - reduced lot size by 10%")
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏ö‡∏ö dynamic (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° Market Conditions)
            profit_target = self.calculate_dynamic_profit_target(lot_size)
            
            # ‡∏õ‡∏£‡∏±‡∏ö profit target ‡∏ï‡∏≤‡∏° Market Conditions (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡∏°‡πà - ‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á = ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ)
            if market_conditions.get('entry_recommendation') == 'high_volatility':
                profit_target *= 1.5  # ‡πÄ‡∏û‡∏¥‡πà‡∏° profit target ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á (‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏î‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ)
                logger.info(f"üìä [PROFIT ADJUSTMENT] High volatility - increased profit target by 50% (great opportunity!)")
            elif market_conditions.get('entry_recommendation') == 'favorable':
                profit_target *= 0.9  # ‡∏•‡∏î profit target ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡∏î‡∏µ (‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô)
                logger.info(f"üìä [PROFIT ADJUSTMENT] Favorable conditions - reduced profit target by 10%")
            elif market_conditions.get('volatility') == 'low':
                profit_target *= 1.1  # ‡πÄ‡∏û‡∏¥‡πà‡∏° profit target ‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î‡∏ô‡∏¥‡πà‡∏á (‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ‡∏ä‡πâ‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô)
                logger.info(f"üìä [PROFIT ADJUSTMENT] Low volatility - increased profit target by 10%")
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á entry opportunity
            if zone_type == 'support':
                direction = 'buy'  # BUY ‡∏ó‡∏µ‡πà Support
                entry_reason = f"Support BUY at {selected_zone['price']:.5f} (Strength: {selected_zone['strength']})"
                logger.info(f"üéØ SELECTED SUPPORT ZONE: {selected_zone['price']:.2f} (Strength: {selected_zone['strength']:.1f})")
            else:  # resistance
                direction = 'sell'  # SELL ‡∏ó‡∏µ‡πà Resistance
                entry_reason = f"Resistance SELL at {selected_zone['price']:.5f} (Strength: {selected_zone['strength']})"
                logger.info(f"üéØ SELECTED RESISTANCE ZONE: {selected_zone['price']:.2f} (Strength: {selected_zone['strength']:.1f})")
            
            entry_opportunity = {
                'direction': direction,
                'entry_price': current_price,
                'zone': selected_zone,
                'reason': entry_reason,
                'priority_score': selected_zone['strength'],
                'zone_type': zone_type,
                'lot_size': lot_size,
                'profit_target': profit_target,
                'loss_threshold': self.calculate_dynamic_loss_threshold(lot_size),
                'market_conditions': market_conditions,  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Market Conditions
                'zone_touches': selected_zone.get('touches', 0),
                'zone_algorithms': len(selected_zone.get('algorithms_used', [])),
                'quality_score': self._calculate_zone_quality_score(selected_zone)
            }
            
            logger.info(f"üéØ Entry Opportunity: {direction.upper()} at {current_price:.5f} "
                       f"(Zone: {selected_zone['price']:.5f}, Strength: {selected_zone['strength']}, "
                       f"Lot: {lot_size:.2f}, Target: ${profit_target:.2f})")
            logger.info(f"üìä Market Conditions: {market_conditions.get('volatility', 'unknown')} volatility, "
                       f"{market_conditions.get('trend', 'unknown')} trend, "
                       f"Recommendation: {market_conditions.get('entry_recommendation', 'neutral')}")
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏•‡∏≤‡∏î‡∏ß‡∏¥‡πà‡∏á
            if market_conditions.get('entry_recommendation') == 'high_volatility':
                logger.info(f"üöÄ [HIGH VOLATILITY TRADE] Market is moving - Great opportunity for profit taking!")
                logger.info(f"üí° [STRATEGY] Enter now to catch the movement and close at higher profit!")
            logger.info(f"üéØ Zone Quality: {selected_zone.get('touches', 0)} touches, "
                       f"{len(selected_zone.get('algorithms_used', []))} algorithms, "
                       f"Quality Score: {self._calculate_zone_quality_score(selected_zone):.1f}")
            
            logger.info(f"‚úÖ [SMART ENTRY] Entry opportunity created successfully - Ready for execution")
            return entry_opportunity
            
        except Exception as e:
            logger.error(f"‚ùå Error analyzing entry opportunity: {e}")
            return None
    
    def find_recovery_opportunity(self, symbol: str, current_price: float, zones: Dict[str, List[Dict]], 
                                 existing_positions: List = None) -> List[Dict]:
        """üöÄ ‡∏´‡∏≤‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏™‡∏£‡πâ‡∏≤‡∏á Recovery Position ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô"""
        try:
            logger.info("=" * 80)
            logger.info("üîß [RECOVERY SYSTEM] Starting recovery opportunity analysis")
            logger.info("=" * 80)
            logger.info(f"üìä [RECOVERY] Checking {len(existing_positions) if existing_positions else 0} positions")
            
            if not existing_positions:
                logger.warning("üö´ [RECOVERY] No existing positions to check")
                return []
            
            recovery_opportunities = []
            
            # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
            losing_positions = 0
            for position in existing_positions:
                try:
                    pos_type = getattr(position, 'type', 0)
                    pos_price = getattr(position, 'price_open', 0)
                    pos_profit = getattr(position, 'profit', 0)
                    pos_lot = getattr(position, 'volume', 0)
                    
                    if not pos_price or not pos_lot:
                        continue
                    
                    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÅ‡∏ö‡∏ö dynamic
                    loss_threshold = self.calculate_dynamic_loss_threshold(pos_lot)
                    
                    logger.debug(f"üîç [RECOVERY] Position: {pos_type} at {pos_price}, Profit: ${pos_profit:.2f}, Threshold: ${loss_threshold:.2f}")
                    
                    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πâ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    if pos_profit >= loss_threshold:
                        logger.debug(f"‚úÖ [RECOVERY] Position profit ${pos_profit:.2f} >= threshold ${loss_threshold:.2f} - No recovery needed")
                        continue  # ‡πÑ‡∏°‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å
                    
                    losing_positions += 1
                    logger.warning(f"üö® [RECOVERY] Losing Position Found: {pos_type} at {pos_price}, Loss: ${pos_profit:.2f} (Threshold: ${loss_threshold:.2f})")
                    
                    # ‡∏´‡∏≤ Zone ‡∏ó‡∏µ‡πà‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Recovery
                    if pos_type == 0:  # BUY ‡πÑ‡∏°‡πâ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
                        # ‡∏´‡∏≤ Support Zone ‡∏ó‡∏µ‡πà‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á SELL Recovery
                        support_zones = zones.get('support', [])
                        logger.info(f"üîç [RECOVERY] For BUY: Found {len(support_zones)} support zones")
                        
                        strong_supports = [zone for zone in support_zones if zone['strength'] >= self.recovery_zone_strength]
                        logger.info(f"üîç [RECOVERY] For BUY: Found {len(strong_supports)} strong support zones (strength >= {self.recovery_zone_strength})")
                        
                        if strong_supports:
                            # ‡∏´‡∏≤ Support ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° (‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πâ BUY)
                            suitable_supports = [zone for zone in strong_supports if zone['price'] < pos_price - 5]  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 20 ‡πÄ‡∏õ‡πá‡∏ô 5 pips
                            logger.info(f"üîç [RECOVERY] For BUY: Found {len(suitable_supports)} suitable supports (price < {pos_price - 5:.2f})")
                            
                            if suitable_supports:
                                best_support = max(suitable_supports, key=lambda x: x['strength'])
                                
                                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Recovery lot size
                                recovery_lot_size = self.calculate_recovery_lot_size(pos_profit, pos_lot)
                                
                                recovery_opportunities.append({
                                    'direction': 'sell',
                                    'entry_price': best_support['price'],
                                    'zone': best_support,
                                    'target_loss': pos_profit,
                                    'target_position_lot': pos_lot,
                                    'reason': f"Recovery SELL for BUY position (Loss: ${pos_profit:.2f})",
                                    'zone_type': 'support'
                                })
                    
                    elif pos_type == 1:  # SELL ‡πÑ‡∏°‡πâ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
                        # ‡∏´‡∏≤ Resistance Zone ‡∏ó‡∏µ‡πà‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á BUY Recovery
                        resistance_zones = zones.get('resistance', [])
                        logger.info(f"üîç [RECOVERY] For SELL: Found {len(resistance_zones)} resistance zones")
                        
                        strong_resistances = [zone for zone in resistance_zones if zone['strength'] >= self.recovery_zone_strength]
                        logger.info(f"üîç [RECOVERY] For SELL: Found {len(strong_resistances)} strong resistance zones (strength >= {self.recovery_zone_strength})")
                        
                        if strong_resistances:
                            # ‡∏´‡∏≤ Resistance ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° (‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πâ SELL)
                            suitable_resistances = [zone for zone in strong_resistances if zone['price'] > pos_price + 5]  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 20 ‡πÄ‡∏õ‡πá‡∏ô 5 pips
                            logger.info(f"üîç [RECOVERY] For SELL: Found {len(suitable_resistances)} suitable resistances (price > {pos_price + 5:.2f})")
                            
                            if suitable_resistances:
                                best_resistance = max(suitable_resistances, key=lambda x: x['strength'])
                                
                                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Recovery lot size
                                recovery_lot_size = self.calculate_recovery_lot_size(pos_profit, pos_lot)
                                
                                recovery_opportunities.append({
                                    'direction': 'buy',
                                    'entry_price': best_resistance['price'],
                                    'zone': best_resistance,
                                    'target_loss': pos_profit,
                                    'target_position_lot': pos_lot,
                                    'reason': f"Recovery BUY for SELL position (Loss: ${pos_profit:.2f})",
                                    'zone_type': 'resistance'
                                })
                
                except Exception as e:
                    logger.error(f"‚ùå Error processing position for recovery: {e}")
                    continue
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏≤‡∏° priority (‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô)
            recovery_opportunities.sort(key=lambda x: x['target_loss'])
            
            logger.info("-" * 80)
            logger.info(f"üìä [RECOVERY] Summary: {losing_positions} losing positions, {len(recovery_opportunities)} recovery opportunities found")
            logger.info("-" * 80)
            
            if recovery_opportunities:
                logger.info("‚úÖ [RECOVERY] Recovery opportunities found:")
                for i, opp in enumerate(recovery_opportunities):
                    logger.info(f"   {i+1}. {opp['reason']} at {opp['entry_price']:.2f}")
            else:
                logger.warning("üö´ [RECOVERY] No recovery opportunities found")
                if losing_positions > 0:
                    logger.warning("   üîß [RECOVERY] Reason: No suitable zones found for recovery")
            
            return recovery_opportunities[:3]  # ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 3 ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™
            
        except Exception as e:
            logger.error(f"‚ùå [RECOVERY] Error finding recovery opportunity: {e}")
            return []
    
    def calculate_recovery_lot_size(self, target_loss: float, target_position_lot: float) -> float:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot size ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Recovery Position"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot size ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πâ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏ó‡∏≥‡∏Å‡∏≥‡πÑ‡∏£
            # ‡πÉ‡∏ä‡πâ lot size ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£ 50 pips
            recovery_lot_size = abs(target_loss) / (self.profit_target_pips * 10)
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° lot size ‡∏Ç‡∏≠‡∏á‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
            if target_position_lot > 0:
                # ‡πÉ‡∏ä‡πâ lot size ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ö‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
                recovery_lot_size = min(recovery_lot_size, target_position_lot * 1.5)
            
            # ‡∏à‡∏≥‡∏Å‡∏±‡∏î lot size
            return max(self.min_lot_size, min(self.max_lot_size, recovery_lot_size))
                
        except Exception as e:
            logger.error(f"‚ùå Error calculating recovery lot size: {e}")
            return self.min_lot_size  # fallback
    
    def get_entry_statistics(self) -> Dict:
        """üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ"""
        try:
            return {
                'daily_trade_count': self.daily_trade_count,
                'max_daily_trades': self.max_daily_trades,
                'used_zones_count': len(self.used_zones),
                'support_buy_enabled': self.support_buy_enabled,
                'resistance_sell_enabled': self.resistance_sell_enabled,
                'min_zone_strength': self.min_zone_strength,
                'recovery_zone_strength': self.recovery_zone_strength,
                'profit_target_pips': self.profit_target_pips,
                'loss_threshold_pips': self.loss_threshold_pips,
                'risk_percent_per_trade': self.risk_percent_per_trade
            }
        except Exception as e:
            logger.error(f"‚ùå Error getting entry statistics: {e}")
            return {}
    def execute_entry(self, entry_plan: Dict) -> Optional[int]:
        """üìà ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ (‡πÉ‡∏ä‡πâ OrderManager ‡πÅ‡∏ó‡∏ô mt5.order_send)"""
        try:
            if not entry_plan:
                return None
            
            direction = entry_plan['direction']
            lot_size = entry_plan['lot_size']
            entry_price = entry_plan['entry_price']
            zone = entry_plan['zone']
            reason = entry_plan['reason']
            
            # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Take Profit ‡πÅ‡∏•‡∏∞ Stop Loss
            profit_target = entry_plan.get('profit_target', 50.0)
            loss_threshold = entry_plan.get('loss_threshold', -50.0)
            
            # ‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏Å‡πâ‡πÑ‡∏°‡πâ - ‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á TP/SL (‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏≠‡∏á)
            tp_price = 0.0  # ‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á TP
            sl_price = 0.0  # ‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á SL
            
            logger.info(f"üöÄ [SMART ENTRY] Executing entry: {direction.upper()} {lot_size:.2f} lots at {entry_price:.5f}")
            logger.info(f"   Reason: {reason}")
            
            # ‡πÉ‡∏ä‡πâ OrderManager ‡πÅ‡∏ó‡∏ô mt5.order_send ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á Signal object ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö OrderManager
            from trading_conditions import Signal
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î comment ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πâ
            if reason and ('Recovery' in str(reason) or 'recovery' in str(reason).lower()):
                comment = f"RECOVERY: {reason}"
                logger.info(f"üîß [SMART ENTRY] Recovery Entry Comment: {comment}")
            else:
                comment = f"SMART_ENTRY: {reason}" if reason else f"SMART_ENTRY: {direction.upper()} at {entry_price:.5f}"
                logger.info(f"üéØ [SMART ENTRY] Smart Entry Comment: {comment}")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö comment ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Signal
            if not comment or comment is None:
                comment = f"SMART_ENTRY: {direction.upper()} at {entry_price:.5f}"
            
            signal = Signal(
                direction=direction.upper(),
                symbol=self.symbol,
                strength=zone.get('strength', 50),
                confidence=80.0,
                timestamp=datetime.now(),
                price=entry_price,
                comment=str(comment),  # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô string ‡πÄ‡∏™‡∏°‡∏≠
                stop_loss=0.0,  # ‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á SL
                take_profit=0.0  # ‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á TP
            )
            
            # ‡πÉ‡∏ä‡πâ OrderManager ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á (‡πÑ‡∏ü‡∏•‡πå order_management.py)
            # ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡πà‡∏á order_manager ‡∏°‡∏≤‡∏à‡∏≤‡∏Å main system
            if hasattr(self, 'order_manager') and self.order_manager:
                logger.info(f"üì§ [SMART ENTRY] Sending order to OrderManager (order_management.py)")
                logger.info(f"   Symbol: {signal.symbol}, Direction: {signal.direction}, Lot: {lot_size:.2f}")
                
                result = self.order_manager.place_order_from_signal(
                    signal=signal,
                    lot_size=lot_size,
                    account_balance=1000.0  # fallback balance
                )
                
                if result and hasattr(result, 'success') and result.success:
                    ticket = getattr(result, 'ticket', None)
                    logger.info(f"‚úÖ [SMART ENTRY] Entry executed via OrderManager: Ticket {ticket}")
                    logger.info(f"   üéØ [SMART ENTRY] Recovery system - No TP/SL (managed by closing system)")
                    
                    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å zone ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
                    zone_key = self._generate_zone_key(zone)
                    self.used_zones[zone_key] = {
                        'timestamp': datetime.now(),
                        'ticket': ticket
                    }
                    
                    # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï daily counter
                    self.daily_trade_count += 1
                    
                    # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                    self.last_trade_time = datetime.now()
                
                    return ticket
                else:
                    error_msg = getattr(result, 'error_message', 'Unknown error') if result else 'No result'
                    logger.error(f"‚ùå [SMART ENTRY] OrderManager failed: {error_msg}")
                    return None
            else:
                logger.error(f"‚ùå [SMART ENTRY] OrderManager not available")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå [SMART ENTRY] Error executing entry: {e}")
            return None
