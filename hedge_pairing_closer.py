# -*- coding: utf-8 -*-
"""
Hedge Pairing Closer Module
‡πÇ‡∏°‡∏î‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡πÅ‡∏ö‡∏ö‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà (Hedge Strategy)
"""

import logging
import itertools
import time
from typing import List, Dict, Optional, Any, Tuple
from dataclasses import dataclass
from datetime import datetime

logger = logging.getLogger(__name__)

@dataclass
class HedgeCombination:
    """‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ"""
    positions: List[Any]
    total_profit: float
    combination_type: str
    size: int
    confidence_score: float
    reason: str

@dataclass
class ClosingDecision:
    """‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ"""
    should_close: bool
    positions_to_close: List[Any]
    method: str
    net_pnl: float
    expected_pnl: float
    position_count: int
    buy_count: int
    sell_count: int
    confidence_score: float
    reason: str

class HedgePairingCloser:
    """üöÄ Hedge Pairing Closer - ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡πÅ‡∏ö‡∏ö‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà"""
    
    def __init__(self):
        # üéØ Hedge Strategy Parameters
        self.min_combination_size = 2      # ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
        self.max_combination_size = 8       # ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
        self.min_net_profit = 0.1          # ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ $0.1
        self.max_acceptable_loss = 5.0     # ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ó‡∏µ‡πà‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ $5.0
        
        # üîß Position Generation Parameters
        self.enable_position_generation = True  # ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÑ‡∏°‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
        self.max_additional_positions = 3       # ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
        self.additional_position_volume = 0.01  # ‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏°‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
        
        # üöÄ Real-time P&L System
        self.pnl_cache = {}  # ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• P&L ‡πÑ‡∏ß‡πâ
        self.cache_timeout = 1.0  # ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        self.portfolio_health_score = "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á"  # ‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏û‡∏≠‡∏£‡πå‡∏ï
        self.performance_history = []  # ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
        self.mt5_connection = None  # ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
        
        logger.info("üöÄ Hedge Pairing Closer initialized")
        logger.info(f"   Min Combination Size: {self.min_combination_size}")
        logger.info(f"   Max Combination Size: {self.max_combination_size}")
        logger.info(f"   Min Net Profit: ${self.min_net_profit}")
        logger.info(f"   Position Generation: {'Enabled' if self.enable_position_generation else 'Disabled'}")
        logger.info("   Real-time P&L: Enabled")
        logger.info("   Portfolio Health Analysis: Enabled")
    
    def set_mt5_connection(self, mt5_connection):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ MT5 Connection ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Real-time P&L"""
        self.mt5_connection = mt5_connection
        logger.info("üîó MT5 Connection set for Real-time P&L")
    
    def _get_real_time_pnl(self, position: Any) -> float:
        """‡∏î‡∏∂‡∏á Floating P&L ‡πÅ‡∏ö‡∏ö Real-time"""
        try:
            # ‡πÉ‡∏ä‡πâ Caching ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
            ticket = getattr(position, 'ticket', 'N/A')
            current_time = time.time()
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ cache ‡∏¢‡∏±‡∏á‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÑ‡∏´‡∏°
            if ticket in self.pnl_cache:
                cached_data = self.pnl_cache[ticket]
                if current_time - cached_data['timestamp'] < self.cache_timeout:
                    return cached_data['pnl']  # ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì P&L ‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            if self.mt5_connection and hasattr(self.mt5_connection, 'get_current_price'):
                current_price = self.mt5_connection.get_current_price(getattr(position, 'symbol', ''))
                if current_price is not None:
                    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì P&L ‡∏à‡∏£‡∏¥‡∏á
                    if getattr(position, 'type', 0) == 0:  # Buy
                        pnl = (current_price - getattr(position, 'open_price', 0)) * getattr(position, 'volume', 0) * 100000
                    else:  # Sell
                        pnl = (getattr(position, 'open_price', 0) - current_price) * getattr(position, 'volume', 0) * 100000
                    
                    # ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô cache
                    self.pnl_cache[ticket] = {
                        'pnl': pnl,
                        'timestamp': current_time
                    }
                    
                    return pnl
            
            # Fallback: ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
            fallback_pnl = getattr(position, 'profit', 0)
            self.pnl_cache[ticket] = {
                'pnl': fallback_pnl,
                'timestamp': current_time
            }
            
            return fallback_pnl
            
        except Exception as e:
            logger.error(f"Error getting real-time P&L: {e}")
            return getattr(position, 'profit', 0)
    
    def _analyze_portfolio_health(self, positions: List[Any], account_balance: float = 1000.0) -> dict:
        """‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏û‡∏≠‡∏£‡πå‡∏ï"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Floating P&L ‡∏à‡∏£‡∏¥‡∏á
            real_pnl_list = [self._get_real_time_pnl(pos) for pos in positions]
            total_pnl = sum(real_pnl_list)
            position_count = len(positions)
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏û‡∏≠‡∏£‡πå‡∏ï
            if total_pnl > 100:
                health_score = "‡∏î‡∏µ‡∏°‡∏≤‡∏Å"
            elif total_pnl > 0:
                health_score = "‡∏î‡∏µ"
            elif total_pnl > -50:
                health_score = "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á"
            elif total_pnl > -100:
                health_score = "‡πÅ‡∏¢‡πà"
            else:
                health_score = "‡πÅ‡∏¢‡πà‡∏°‡∏≤‡∏Å"
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πâ
            avg_balance_per_position = account_balance / position_count if position_count > 0 else account_balance
            
            self.portfolio_health_score = health_score
            
            return {
                'total_pnl': total_pnl,
                'position_count': position_count,
                'health_score': health_score,
                'avg_balance_per_position': avg_balance_per_position,
                'avg_pnl_per_position': total_pnl / position_count if position_count > 0 else 0
            }
        except Exception as e:
            logger.error(f"Error analyzing portfolio health: {e}")
            return {'health_score': '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á', 'total_pnl': 0}
    
    def find_optimal_closing(self, positions: List[Any], account_info: Dict, 
                           market_conditions: Optional[Dict] = None) -> Optional[ClosingDecision]:
        """
        üß† ‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÅ‡∏ö‡∏ö‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
        """
        start_time = time.time()
        try:
            if len(positions) < 1:
                logger.info("‚è∏Ô∏è Need at least 1 position for analysis")
                return None
            
            logger.info(f"üîç HEDGE ANALYSIS: {len(positions)} positions")
            
            # Step 1: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏û‡∏≠‡∏£‡πå‡∏ï
            account_balance = account_info.get('balance', 1000.0)
            portfolio_health = self._analyze_portfolio_health(positions, account_balance)
            logger.info(f"üìä Portfolio Health: {portfolio_health['health_score']} (P&L: ${portfolio_health['total_pnl']:.2f})")
            
            # Step 2: Smart Filtering - ‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô
            filtered_positions = self._smart_filter_positions(positions, account_balance)
            logger.info(f"üîç Smart Filtering: {len(positions)} ‚Üí {len(filtered_positions)} positions")
            
            # 1. ‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
            profitable_combinations = self._find_profitable_combinations(filtered_positions)
            
            if profitable_combinations:
                # ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° ‚Üí ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ
                best_combination = profitable_combinations[0]
                logger.info(f"‚úÖ HEDGE COMBINATION FOUND: {best_combination.combination_type}")
                logger.info(f"   Net P&L: ${best_combination.total_profit:.2f}")
                logger.info(f"   Positions: {best_combination.size}")
                
                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
                processing_time = time.time() - start_time
                self._record_performance(True, best_combination.total_profit, processing_time)
                
                return ClosingDecision(
                    should_close=True,
                    positions_to_close=best_combination.positions,
                    method="HEDGE_PAIRING",
                    net_pnl=best_combination.total_profit,
                    expected_pnl=best_combination.total_profit,
                    position_count=best_combination.size,
                    buy_count=sum(1 for p in best_combination.positions if p.type == 0),
                    sell_count=sum(1 for p in best_combination.positions if p.type == 1),
                    confidence_score=best_combination.confidence_score,
                    reason=best_combination.reason
                )
            
            # 2. ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° ‚Üí ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
            logger.info("=" * 60)
            logger.info("üí§ NO PROFITABLE COMBINATIONS FOUND")
            logger.info("=" * 60)
            logger.info(f"üìä Current positions: {len(positions)} total")
            logger.info(f"üìä Buy positions: {len([p for p in positions if getattr(p, 'type', 0) == 0])}")
            logger.info(f"üìä Sell positions: {len([p for p in positions if getattr(p, 'type', 0) == 1])}")
            
            logger.info("-" * 40)
            logger.info("üìã DETAILED POSITION LIST")
            logger.info("-" * 40)
            # ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            for pos in positions:
                pos_type = "BUY" if getattr(pos, 'type', 0) == 0 else "SELL"
                profit = getattr(pos, 'profit', 0)
                ticket = getattr(pos, 'ticket', 'N/A')
                has_hedge = self._has_hedge_pair(positions, pos)
                hedge_status = "üîó HEDGED" if has_hedge else "üí§ NO HEDGE"
                logger.info(f"   {ticket}: {pos_type} ${profit:.2f} - {hedge_status}")
            
            logger.info("=" * 60)
            
            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
            processing_time = time.time() - start_time
            self._record_performance(False, 0.0, processing_time)
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error in hedge pairing analysis: {e}")
            processing_time = time.time() - start_time
            self._record_performance(False, 0.0, processing_time)
            return None
    
    def _smart_filter_positions(self, positions: List[Any], account_balance: float = 1000.0) -> List[Any]:
        """üîç Smart Filtering - ‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì threshold ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô
            threshold = self._calculate_portfolio_threshold(account_balance, len(positions))
            
            filtered_positions = []
            for pos in positions:
                # ‡πÉ‡∏ä‡πâ P&L ‡πÅ‡∏ö‡∏ö Real-time
                real_pnl = self._get_real_time_pnl(pos)
                volume = getattr(pos, 'volume', 0)
                
                # ‡∏Ñ‡∏±‡∏î‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç (‡πÉ‡∏ä‡πâ threshold ‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô)
                if real_pnl >= -threshold:  # ‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                    if volume >= 0.01:  # ‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                        if abs(real_pnl) >= 0.1:  # ‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£/‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
                            filtered_positions.append(pos)
                        else:
                            logger.debug(f"üîç Filtered out: {getattr(pos, 'ticket', 'N/A')} (profit too small: ${real_pnl:.2f})")
                    else:
                        logger.debug(f"üîç Filtered out: {getattr(pos, 'ticket', 'N/A')} (volume too small: {volume:.2f})")
                else:
                    logger.debug(f"üîç Filtered out: {getattr(pos, 'ticket', 'N/A')} (loss too large: ${real_pnl:.2f})")
            
            logger.info(f"üîç Smart Filtering: {len(positions)} ‚Üí {len(filtered_positions)} positions (threshold: ${threshold:.2f})")
            return filtered_positions
            
        except Exception as e:
            logger.error(f"‚ùå Error in smart filtering: {e}")
            return positions  # Return original positions if error
    
    def _calculate_portfolio_threshold(self, account_balance: float, position_count: int) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì threshold ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô"""
        try:
            if position_count == 0:
                return 0.0
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πâ
            avg_balance_per_position = account_balance / position_count
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì threshold ‡∏ï‡∏≤‡∏°‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô
            threshold_percentage = self._get_threshold_percentage()
            threshold = avg_balance_per_position * threshold_percentage
            
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Min/Max threshold
            min_threshold = 1.0   # ‡πÑ‡∏°‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ $1.00
            max_threshold = 100.0 # ‡πÑ‡∏°‡πà‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤ $100.00
            
            threshold = max(min_threshold, min(threshold, max_threshold))
            
            return threshold
        except Exception as e:
            logger.error(f"Error calculating portfolio threshold: {e}")
            return 10.0
    
    def _get_threshold_percentage(self) -> float:
        """‡πÑ‡∏î‡πâ threshold percentage ‡∏ï‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏û‡∏≠‡∏£‡πå‡∏ï"""
        try:
            if self.portfolio_health_score == "‡∏î‡∏µ‡∏°‡∏≤‡∏Å":
                return 0.05  # 5%
            elif self.portfolio_health_score == "‡∏î‡∏µ":
                return 0.08  # 8%
            elif self.portfolio_health_score == "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á":
                return 0.10  # 10%
            elif self.portfolio_health_score == "‡πÅ‡∏¢‡πà":
                return 0.15  # 15%
            else:  # ‡πÅ‡∏¢‡πà‡∏°‡∏≤‡∏Å
                return 0.20  # 20%
        except Exception as e:
            logger.error(f"Error getting threshold percentage: {e}")
            return 0.10  # Default 10%
    
    def _priority_based_selection(self, positions: List[Any]) -> List[Any]:
        """üéØ Priority-based Selection - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Priority Score ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÑ‡∏°‡πâ
            priority_scores = []
            for pos in positions:
                priority_score = self._calculate_priority_score(pos)
                priority_scores.append((priority_score, pos))
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° Priority Score (‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô)
            priority_scores.sort(key=lambda x: x[0], reverse=True)
            
            # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏°‡∏µ Priority ‡∏™‡∏π‡∏á (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 15 ‡πÑ‡∏°‡πâ)
            max_positions = min(15, len(positions))
            priority_positions = [pos for _, pos in priority_scores[:max_positions]]
            
            logger.info(f"üéØ Priority Selection: {len(positions)} ‚Üí {len(priority_positions)} positions")
            return priority_positions
            
        except Exception as e:
            logger.error(f"‚ùå Error in priority selection: {e}")
            return positions  # Return original positions if error
    
    def _calculate_priority_score(self, position: Any) -> float:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Priority Score ‡∏à‡∏≤‡∏Å Real-time P&L"""
        try:
            # ‡πÉ‡∏ä‡πâ P&L ‡πÅ‡∏ö‡∏ö Real-time
            real_pnl = self._get_real_time_pnl(position)
            volume = getattr(position, 'volume', 0)
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Priority Score
            priority_score = 0
            
            # ‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£‡∏°‡∏≤‡∏Å = Priority ‡∏™‡∏π‡∏á
            if real_pnl > 0:
                priority_score += real_pnl * 10
            
            # ‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ô‡πâ‡∏≠‡∏¢ = Priority ‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á
            elif real_pnl > -2.0:
                priority_score += abs(real_pnl) * 5
            
            # ‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏°‡∏≤‡∏Å = Priority ‡∏ï‡πà‡∏≥
            else:
                priority_score += abs(real_pnl) * 2
            
            # ‡∏õ‡∏£‡∏¥‡∏°‡∏≤‡∏ì‡∏°‡∏≤‡∏Å = Priority ‡∏™‡∏π‡∏á
            priority_score += volume * 100
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ï‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏û‡∏≠‡∏£‡πå‡∏ï
            if self.portfolio_health_score == "‡∏î‡∏µ‡∏°‡∏≤‡∏Å":
                priority_score *= 1.2  # ‡πÄ‡∏û‡∏¥‡πà‡∏° 20%
            elif self.portfolio_health_score == "‡∏î‡∏µ":
                priority_score *= 1.1  # ‡πÄ‡∏û‡∏¥‡πà‡∏° 10%
            elif self.portfolio_health_score == "‡πÅ‡∏¢‡πà":
                priority_score *= 0.9   # ‡∏•‡∏î 10%
            elif self.portfolio_health_score == "‡πÅ‡∏¢‡πà‡∏°‡∏≤‡∏Å":
                priority_score *= 0.8  # ‡∏•‡∏î 20%
            
            return priority_score
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating priority score: {e}")
            return 0.0
    
    def _validate_system_performance(self) -> dict:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ö‡∏ö Real-time"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
            accuracy_score = self._calculate_accuracy_score()
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πâ
            efficiency_score = self._calculate_efficiency_score()
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
            speed_score = self._calculate_speed_score()
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Overall Performance Score
            overall_score = (accuracy_score + efficiency_score + speed_score) / 3
            
            return {
                'accuracy_score': accuracy_score,
                'efficiency_score': efficiency_score,
                'speed_score': speed_score,
                'overall_score': overall_score,
                'status': '‡∏î‡∏µ‡∏°‡∏≤‡∏Å' if overall_score > 0.8 else '‡∏î‡∏µ' if overall_score > 0.6 else '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á'
            }
        except Exception as e:
            logger.error(f"Error validating system performance: {e}")
            return {}
    
    def _calculate_accuracy_score(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Accuracy Score"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
            if len(self.performance_history) < 5:
                return 0.75  # Default score
            
            recent_performance = self.performance_history[-10:]  # 10 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            successful_closes = sum(1 for p in recent_performance if p.get('success', False))
            accuracy = successful_closes / len(recent_performance)
            
            return accuracy
        except Exception as e:
            logger.error(f"Error calculating accuracy score: {e}")
            return 0.75
    
    def _calculate_efficiency_score(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Efficiency Score"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
            if len(self.performance_history) < 5:
                return 0.70  # Default score
            
            recent_performance = self.performance_history[-10:]  # 10 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            avg_profit = sum(p.get('profit', 0) for p in recent_performance) / len(recent_performance)
            
            # Normalize efficiency score (0-1)
            efficiency = min(1.0, max(0.0, (avg_profit + 10) / 20))  # -10 to +10 range
            
            return efficiency
        except Exception as e:
            logger.error(f"Error calculating efficiency score: {e}")
            return 0.70
    
    def _calculate_speed_score(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Speed Score"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
            if len(self.performance_history) < 5:
                return 0.80  # Default score
            
            recent_performance = self.performance_history[-10:]  # 10 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            avg_time = sum(p.get('processing_time', 1.0) for p in recent_performance) / len(recent_performance)
            
            # Normalize speed score (0-1) - ‡∏¢‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß‡∏¢‡∏¥‡πà‡∏á‡∏î‡∏µ
            speed = max(0.0, min(1.0, 2.0 - avg_time))  # 0-2 seconds range
            
            return speed
        except Exception as e:
            logger.error(f"Error calculating speed score: {e}")
            return 0.80
    
    def _record_performance(self, success: bool, profit: float, processing_time: float):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û"""
        try:
            performance_record = {
                'timestamp': time.time(),
                'success': success,
                'profit': profit,
                'processing_time': processing_time,
                'portfolio_health': self.portfolio_health_score
            }
            
            self.performance_history.append(performance_record)
            
            # ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞ 100 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            if len(self.performance_history) > 100:
                self.performance_history = self.performance_history[-100:]
                
        except Exception as e:
            logger.error(f"Error recording performance: {e}")
    
    def _dynamic_re_pairing(self, hedge_pair: dict, positions: List[Any]) -> Optional[HedgeCombination]:
        """üîÑ Dynamic Re-pairing - ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏ö‡∏ö Dynamic"""
        try:
            # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ
            used_tickets = set()
            for pair in self._find_existing_hedge_pairs(positions):
                used_tickets.add(getattr(pair['buy'], 'ticket', 'N/A'))
                used_tickets.add(getattr(pair['sell'], 'ticket', 'N/A'))
            
            available_positions = [pos for pos in positions 
                                 if getattr(pos, 'ticket', 'N/A') not in used_tickets]
            
            if len(available_positions) < 2:
                return None
            
            # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÉ‡∏´‡∏°‡πà
            best_alternative = None
            best_profit = -float('inf')
            
            for i, pos1 in enumerate(available_positions):
                for j, pos2 in enumerate(available_positions[i+1:], i+1):
                    if getattr(pos1, 'type', 0) != getattr(pos2, 'type', 0):  # ‡πÑ‡∏°‡πâ‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
                        test_profit = getattr(pos1, 'profit', 0) + getattr(pos2, 'profit', 0)
                        
                        if test_profit > best_profit and test_profit >= self.min_net_profit:
                            best_alternative = [pos1, pos2]
                            best_profit = test_profit
            
            if best_alternative:
                return HedgeCombination(
                    positions=best_alternative,
                    total_profit=best_profit,
                    combination_type="DYNAMIC_RE_PAIRING",
                    size=2,
                    confidence_score=80.0,
                    reason="Dynamic re-pairing: Alternative pair found"
                )
            
            return None
            
        except Exception as e:
            logger.error(f"‚ùå Error in dynamic re-pairing: {e}")
            return None
    
    def _find_profitable_combinations(self, positions: List[Any]) -> List[HedgeCombination]:
        """üîç ‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏ú‡∏•‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ö‡∏ß‡∏Å (‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£ Hedge ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)"""
        try:
            # Step 2: Priority-based Selection - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
            priority_positions = self._priority_based_selection(positions)
            logger.info(f"üîç Priority Selection: {len(positions)} ‚Üí {len(priority_positions)} positions")
            
            # ‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏ö‡∏ö Hedge ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
            hedge_combinations = self._find_hedge_combinations(priority_positions)
            if hedge_combinations:
                logger.info("-" * 40)
                logger.info("‚úÖ HEDGE COMBINATIONS FOUND")
                logger.info("-" * 40)
                logger.info(f"üéØ Total combinations: {len(hedge_combinations)}")
                for i, combo in enumerate(hedge_combinations[:3]):  # ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏Ñ‡πà 3 ‡∏≠‡∏±‡∏ô‡πÅ‡∏£‡∏Å
                    logger.info(f"   {i+1}. {combo.combination_type}: ${combo.total_profit:.2f} ({combo.size} positions)")
                if len(hedge_combinations) > 3:
                    logger.info(f"   ... and {len(hedge_combinations) - 3} more combinations")
                logger.info("=" * 60)
                return hedge_combinations
            
            # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏°‡∏µ Hedge ‡πÅ‡∏•‡πâ‡∏ß
            unpaired_profitable = []  # ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà
            unpaired_losing = []     # ‡πÑ‡∏°‡πâ‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà
            existing_hedge_pairs = [] # Hedge pairs ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
            
            # ‡πÅ‡∏¢‡∏Å‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
            for pos in positions:
                pos_ticket = getattr(pos, 'ticket', 'N/A')
                pos_profit = getattr(pos, 'profit', 0)
                has_hedge = self._has_hedge_pair(positions, pos)
                
                if not has_hedge:
                    if pos_profit >= self.min_net_profit:
                        unpaired_profitable.append(pos)
                        logger.info(f"üîç Unpaired profitable position: {pos_ticket} (${pos_profit:.2f})")
                    else:
                        unpaired_losing.append(pos)
                        logger.info(f"üîç Unpaired losing position: {pos_ticket} (${pos_profit:.2f}) - waiting for opposite")
                else:
                    logger.info(f"üîç Hedged position: {pos_ticket} (${pos_profit:.2f})")
            
            # ‡∏´‡∏≤ Hedge pairs ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
            existing_hedge_pairs = self._find_existing_hedge_pairs(positions)
            
            logger.info("-" * 40)
            logger.info("üìä POSITION STATUS SUMMARY")
            logger.info("-" * 40)
            logger.info(f"üí∞ Unpaired profitable: {len(unpaired_profitable)}")
            logger.info(f"üìâ Unpaired losing: {len(unpaired_losing)}")
            logger.info(f"üîó Existing hedge pairs: {len(existing_hedge_pairs)}")
            
            # ‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î: ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà + Hedge pairs ‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏•‡∏ö
            profitable_combinations = self._find_helping_combinations(unpaired_profitable, existing_hedge_pairs)
            
            # ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡πÅ‡∏ö‡∏ö‡∏ú‡∏™‡∏°‡∏≠‡∏∑‡πà‡∏ô‡πÜ - ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Å‡∏≥‡πÑ‡∏£ (‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô)
            profitable_combinations.sort(key=lambda x: x.total_profit, reverse=True)
            
            logger.info(f"üîç Found {len(profitable_combinations)} profitable combinations")
            return profitable_combinations
            
        except Exception as e:
            logger.error(f"‚ùå Error finding profitable combinations: {e}")
            return []
    
    def _is_same_type_combination(self, combination: List[Any]) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        try:
            if len(combination) < 2:
                return False
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏°‡πâ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            first_type = getattr(combination[0], 'type', 0)
            for pos in combination[1:]:
                if getattr(pos, 'type', 0) != first_type:
                    return False  # ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
            
            return True  # ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
            
        except Exception as e:
            logger.error(f"‚ùå Error checking same type combination: {e}")
            return False
    
    def _find_hedge_combinations(self, positions: List[Any]) -> List[HedgeCombination]:
        """‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏ö‡∏ö Hedge (‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏™‡∏°‡∏≠)"""
        try:
            hedge_combinations = []
            
            # ‡πÅ‡∏¢‡∏Å‡πÑ‡∏°‡πâ Buy ‡πÅ‡∏•‡∏∞ Sell
            buy_positions = [p for p in positions if getattr(p, 'type', 0) == 0]
            sell_positions = [p for p in positions if getattr(p, 'type', 0) == 1]
            
            logger.info("=" * 60)
            logger.info("üîç HEDGE ANALYSIS START")
            logger.info("=" * 60)
            logger.info(f"üìä Positions: {len(buy_positions)} Buy, {len(sell_positions)} Sell (Total: {len(positions)})")
            logger.info(f"üîç Looking for hedge pairs without duplication...")
            
            # Step 1: ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏™‡∏°‡∏≠ (‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô)
            hedge_pairs = []
            used_positions = set()  # ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
            
            # ‡∏´‡∏≤ Buy ‡∏ï‡∏¥‡∏î‡∏•‡∏ö + Sell ‡∏Å‡∏≥‡πÑ‡∏£ (‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô)
            for buy_pos in buy_positions:
                if getattr(buy_pos, 'profit', 0) < 0:  # Buy ‡∏ï‡∏¥‡∏î‡∏•‡∏ö
                    buy_ticket = getattr(buy_pos, 'ticket', 'N/A')
                    if buy_ticket in used_positions:
                        continue  # ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
                    
                    for sell_pos in sell_positions:
                        if getattr(sell_pos, 'profit', 0) > 0:  # Sell ‡∏Å‡∏≥‡πÑ‡∏£
                            sell_ticket = getattr(sell_pos, 'ticket', 'N/A')
                            if sell_ticket in used_positions:
                                continue  # ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
                            
                            # ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ
                            hedge_pairs.append({
                                'buy': buy_pos,
                                'sell': sell_pos,
                                'type': 'BUY_LOSS_SELL_PROFIT'
                            })
                            used_positions.add(buy_ticket)
                            used_positions.add(sell_ticket)
                            logger.info(f"üîç Found hedge pair: Buy {buy_ticket} (${getattr(buy_pos, 'profit', 0):.2f}) + Sell {sell_ticket} (${getattr(sell_pos, 'profit', 0):.2f})")
                            logger.info(f"   Used positions: {list(used_positions)}")
                            break  # ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
            
            # ‡∏´‡∏≤ Sell ‡∏ï‡∏¥‡∏î‡∏•‡∏ö + Buy ‡∏Å‡∏≥‡πÑ‡∏£ (‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô)
            for sell_pos in sell_positions:
                if getattr(sell_pos, 'profit', 0) < 0:  # Sell ‡∏ï‡∏¥‡∏î‡∏•‡∏ö
                    sell_ticket = getattr(sell_pos, 'ticket', 'N/A')
                    if sell_ticket in used_positions:
                        continue  # ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
                    
                    for buy_pos in buy_positions:
                        if getattr(buy_pos, 'profit', 0) > 0:  # Buy ‡∏Å‡∏≥‡πÑ‡∏£
                            buy_ticket = getattr(buy_pos, 'ticket', 'N/A')
                            if buy_ticket in used_positions:
                                continue  # ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
                            
                            # ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ
                            hedge_pairs.append({
                                'buy': buy_pos,
                                'sell': sell_pos,
                                'type': 'SELL_LOSS_BUY_PROFIT'
                            })
                            used_positions.add(sell_ticket)
                            used_positions.add(buy_ticket)
                            logger.info(f"üîç Found hedge pair: Sell {sell_ticket} (${getattr(sell_pos, 'profit', 0):.2f}) + Buy {buy_ticket} (${getattr(buy_pos, 'profit', 0):.2f})")
                            logger.info(f"   Used positions: {list(used_positions)}")
                            break  # ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
            logger.info("-" * 40)
            logger.info("üìä HEDGE PAIRING SUMMARY")
            logger.info("-" * 40)
            logger.info(f"‚úÖ Hedge pairs found: {len(hedge_pairs)}")
            logger.info(f"üìã Used positions: {list(used_positions)}")
            logger.info(f"üìã Unused positions: {len(positions) - len(used_positions)}")
            
            # ‡πÅ‡∏™‡∏î‡∏á‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏°‡∏µ Hedge
            hedged_positions = []
            for pos in positions:
                if self._has_hedge_pair(positions, pos):
                    hedged_positions.append(getattr(pos, 'ticket', 'N/A'))
            
            if hedged_positions:
                logger.info(f"üîó Hedged positions: {hedged_positions}")
                logger.info(f"‚ö†Ô∏è  These positions will NOT be closed individually - waiting for additional positions")
            
            # Step 2: ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏°‡∏≤‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
            for hedge_pair in hedge_pairs:
                hedge_profit = getattr(hedge_pair['buy'], 'profit', 0) + getattr(hedge_pair['sell'], 'profit', 0)
                
                # ‡∏ñ‡πâ‡∏≤ hedge pair ‡∏ï‡∏¥‡∏î‡∏•‡∏ö ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏°‡∏≤‡∏ä‡πà‡∏ß‡∏¢
                if hedge_profit < 0:
                    logger.info(f"üîç Hedge pair is losing (${hedge_profit:.2f}), looking for additional profitable positions...")
                    
                    # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß
                    additional_positions = []
                    for pos in positions:
                        pos_ticket = getattr(pos, 'ticket', 'N/A')
                        if pos_ticket not in used_positions and getattr(pos, 'profit', 0) > 0:
                            additional_positions.append(pos)
                    
                    logger.debug(f"üîç Found {len(additional_positions)} additional profitable positions")
                    
                    # ‡∏•‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡πÑ‡∏£
                    best_combination = None
                    best_profit = hedge_profit
                    
                    # Early termination - ‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö
                    max_attempts = min(len(additional_positions), 3)  # ‡∏•‡∏î‡∏à‡∏≤‡∏Å 5 ‡πÄ‡∏õ‡πá‡∏ô 3
                    
                    for i in range(1, min(len(additional_positions) + 1, max_attempts + 1)):
                        for combo in itertools.combinations(additional_positions, i):
                            test_positions = [hedge_pair['buy'], hedge_pair['sell']] + list(combo)
                            test_profit = sum(getattr(pos, 'profit', 0) for pos in test_positions)
                            
                        if test_profit > best_profit and test_profit >= self.min_net_profit:
                            best_combination = test_positions
                            best_profit = test_profit
                            # ‡∏•‡∏î log output - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏ö combination ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å
                            if test_profit > best_profit * 1.5:  # ‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 50%
                                logger.info(f"‚úÖ Found better combination: ${test_profit:.2f} with {len(test_positions)} positions")
                            
                            # Early break - ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏ö combination ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏û‡∏≠
                            if test_profit >= self.min_net_profit * 2:  # ‡∏Å‡∏≥‡πÑ‡∏£‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 2 ‡πÄ‡∏ó‡πà‡∏≤‡∏Ç‡∏≠‡∏á threshold
                                break
                    
                    if best_combination:
                        hedge_combinations.append(HedgeCombination(
                            positions=best_combination,
                            total_profit=best_profit,
                            combination_type=f"HEDGE_{hedge_pair['type']}_WITH_ADDITIONAL",
                            size=len(best_combination),
                            confidence_score=95.0,
                            reason=f"Hedge: {hedge_pair['type']} with additional profitable positions"
                        ))
                        logger.info(f"‚úÖ Complete hedge combination found: ${best_profit:.2f}")
                    else:
                        logger.info(f"‚ö†Ô∏è No profitable combination found for hedge pair (${hedge_profit:.2f})")
                        # Step 3: Dynamic Re-pairing - ‡∏•‡∏≠‡∏á‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÉ‡∏´‡∏°‡πà
                        alternative_pair = self._dynamic_re_pairing(hedge_pair, positions)
                        if alternative_pair:
                            hedge_combinations.append(alternative_pair)
                            logger.info(f"üîÑ Dynamic Re-pairing: Found alternative pair")
                        # ‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° hedge pair ‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏•‡∏ö
                else:
                    # ‡∏ñ‡πâ‡∏≤ hedge pair ‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
                    logger.info(f"‚úÖ Hedge pair is profitable: ${hedge_profit:.2f}")
                    hedge_combinations.append(HedgeCombination(
                        positions=[hedge_pair['buy'], hedge_pair['sell']],
                        total_profit=hedge_profit,
                        combination_type=f"HEDGE_{hedge_pair['type']}_ONLY",
                        size=2,
                        confidence_score=90.0,
                        reason=f"Hedge: {hedge_pair['type']} (profitable pair)"
                    ))
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Å‡∏≥‡πÑ‡∏£ (‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô)
            hedge_combinations.sort(key=lambda x: x.total_profit, reverse=True)
            
            return hedge_combinations
            
        except Exception as e:
            logger.error(f"‚ùå Error finding hedge combinations: {e}")
            return []
    
    def _find_additional_profitable_positions(self, positions: List[Any], hedge_buy: Any, hedge_sell: Any) -> List[Any]:
        """‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ Hedge ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏≠‡∏∑‡πà‡∏ô"""
        try:
            additional_positions = []
            
            # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡πÑ‡∏£
            for pos in positions:
                if pos == hedge_buy or pos == hedge_sell:
                    continue  # ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà Hedge ‡πÅ‡∏•‡πâ‡∏ß
                
                if getattr(pos, 'profit', 0) > 0:  # ‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£
                    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πâ‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ Hedge ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏≠‡∏∑‡πà‡∏ô
                    if not self._has_hedge_pair(positions, pos):
                        additional_positions.append(pos)
                        logger.info(f"üîç Found additional profitable position: {getattr(pos, 'ticket', 'N/A')} (${getattr(pos, 'profit', 0):.2f})")
            
            return additional_positions
            
        except Exception as e:
            logger.error(f"‚ùå Error finding additional positions: {e}")
            return []
    
    def _find_existing_hedge_pairs(self, positions: List[Any]) -> List[dict]:
        """‡∏´‡∏≤ Hedge pairs ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß"""
        try:
            hedge_pairs = []
            used_positions = set()
            
            # ‡πÅ‡∏¢‡∏Å‡πÑ‡∏°‡πâ Buy ‡πÅ‡∏•‡∏∞ Sell
            buy_positions = [p for p in positions if getattr(p, 'type', 0) == 0]
            sell_positions = [p for p in positions if getattr(p, 'type', 0) == 1]
            
            # ‡∏´‡∏≤ Buy ‡∏ï‡∏¥‡∏î‡∏•‡∏ö + Sell ‡∏Å‡∏≥‡πÑ‡∏£
            for buy_pos in buy_positions:
                if getattr(buy_pos, 'profit', 0) < 0:  # Buy ‡∏ï‡∏¥‡∏î‡∏•‡∏ö
                    buy_ticket = getattr(buy_pos, 'ticket', 'N/A')
                    if buy_ticket in used_positions:
                        continue
                    
                    for sell_pos in sell_positions:
                        if getattr(sell_pos, 'profit', 0) > 0:  # Sell ‡∏Å‡∏≥‡πÑ‡∏£
                            sell_ticket = getattr(sell_pos, 'ticket', 'N/A')
                            if sell_ticket in used_positions:
                                continue
                            
                            # ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ
                            total_profit = getattr(buy_pos, 'profit', 0) + getattr(sell_pos, 'profit', 0)
                            hedge_pairs.append({
                                'buy': buy_pos,
                                'sell': sell_pos,
                                'total_profit': total_profit,
                                'type': 'BUY_LOSS_SELL_PROFIT',
                                'positions': [buy_pos, sell_pos]
                            })
                            used_positions.add(buy_ticket)
                            used_positions.add(sell_ticket)
                            logger.info(f"üîç Existing hedge pair: Buy {buy_ticket} + Sell {sell_ticket} = ${total_profit:.2f}")
                            break
            
            # ‡∏´‡∏≤ Sell ‡∏ï‡∏¥‡∏î‡∏•‡∏ö + Buy ‡∏Å‡∏≥‡πÑ‡∏£
            for sell_pos in sell_positions:
                if getattr(sell_pos, 'profit', 0) < 0:  # Sell ‡∏ï‡∏¥‡∏î‡∏•‡∏ö
                    sell_ticket = getattr(sell_pos, 'ticket', 'N/A')
                    if sell_ticket in used_positions:
                        continue
                    
                    for buy_pos in buy_positions:
                        if getattr(buy_pos, 'profit', 0) > 0:  # Buy ‡∏Å‡∏≥‡πÑ‡∏£
                            buy_ticket = getattr(buy_pos, 'ticket', 'N/A')
                            if buy_ticket in used_positions:
                                continue
                            
                            # ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ
                            total_profit = getattr(sell_pos, 'profit', 0) + getattr(buy_pos, 'profit', 0)
                            hedge_pairs.append({
                                'buy': buy_pos,
                                'sell': sell_pos,
                                'total_profit': total_profit,
                                'type': 'SELL_LOSS_BUY_PROFIT',
                                'positions': [sell_pos, buy_pos]
                            })
                            used_positions.add(sell_ticket)
                            used_positions.add(buy_ticket)
                            logger.info(f"üîç Existing hedge pair: Sell {sell_ticket} + Buy {buy_ticket} = ${total_profit:.2f}")
                            break
            
            return hedge_pairs
            
        except Exception as e:
            logger.error(f"‚ùå Error finding existing hedge pairs: {e}")
            return []
    
    def _find_helping_combinations(self, unpaired_profitable: List[Any], existing_hedge_pairs: List[dict]) -> List[HedgeCombination]:
        """‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà‡πÑ‡∏õ‡∏ä‡πà‡∏ß‡∏¢ Hedge pairs ‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏•‡∏ö"""
        try:
            helping_combinations = []
            
            if not unpaired_profitable or not existing_hedge_pairs:
                logger.info("üí§ No unpaired profitable positions or existing hedge pairs to help")
                return helping_combinations
            
            # ‡∏´‡∏≤ Hedge pairs ‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏•‡∏ö
            losing_hedge_pairs = [pair for pair in existing_hedge_pairs if pair['total_profit'] < 0]
            
            if not losing_hedge_pairs:
                logger.info("üí§ No losing hedge pairs to help")
                return helping_combinations
            
            logger.info("-" * 40)
            logger.info("üîç HELPING COMBINATIONS ANALYSIS")
            logger.info("-" * 40)
            logger.info(f"üí∞ Unpaired profitable positions: {len(unpaired_profitable)}")
            logger.info(f"üìâ Losing hedge pairs to help: {len(losing_hedge_pairs)}")
            
            # ‡∏•‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡πÑ‡∏°‡πâ‡∏Å‡∏≥‡πÑ‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà
            for size in range(1, len(unpaired_profitable) + 1):
                for profitable_combo in itertools.combinations(unpaired_profitable, size):
                    profitable_total = sum(getattr(pos, 'profit', 0) for pos in profitable_combo)
                    
                    # ‡∏•‡∏≠‡∏á‡∏ä‡πà‡∏ß‡∏¢ Hedge pairs ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏π‡πà
                    for hedge_pair in losing_hedge_pairs:
                        combined_profit = profitable_total + hedge_pair['total_profit']
                        
                        logger.info(f"üîç Testing: {len(profitable_combo)} profitable positions (${profitable_total:.2f}) + hedge pair (${hedge_pair['total_profit']:.2f}) = ${combined_profit:.2f}")
                        
                        if combined_profit >= self.min_net_profit:
                            # ‡∏£‡∏ß‡∏°‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                            all_positions = list(profitable_combo) + hedge_pair['positions']
                            
                            helping_combinations.append(HedgeCombination(
                                positions=all_positions,
                                total_profit=combined_profit,
                                combination_type=f"HELPING_{hedge_pair['type']}",
                                size=len(all_positions),
                                confidence_score=95.0,
                                reason=f"Unpaired profitable positions helping hedge pair: {hedge_pair['type']}"
                            ))
                            
                            logger.info(f"‚úÖ Found helping combination: ${combined_profit:.2f}")
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Å‡∏≥‡πÑ‡∏£ (‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô)
            helping_combinations.sort(key=lambda x: x.total_profit, reverse=True)
            
            return helping_combinations
            
        except Exception as e:
            logger.error(f"‚ùå Error finding helping combinations: {e}")
            return []
    
    def _has_hedge_pair(self, positions: List[Any], position: Any) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πâ‡∏ô‡∏µ‡πâ‡∏°‡∏µ Hedge ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏≠‡∏∑‡πà‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å used_positions)"""
        try:
            # ‡∏´‡∏≤ used_positions ‡∏à‡∏≤‡∏Å hedge pairs ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß
            used_positions = set()
            
            # ‡∏´‡∏≤ hedge pairs ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß
            buy_positions = [p for p in positions if getattr(p, 'type', 0) == 0]
            sell_positions = [p for p in positions if getattr(p, 'type', 0) == 1]
            
            # ‡∏´‡∏≤ Buy ‡∏ï‡∏¥‡∏î‡∏•‡∏ö + Sell ‡∏Å‡∏≥‡πÑ‡∏£
            for buy_pos in buy_positions:
                if getattr(buy_pos, 'profit', 0) < 0:
                    buy_ticket = getattr(buy_pos, 'ticket', 'N/A')
                    if buy_ticket in used_positions:
                        continue
                    
                    for sell_pos in sell_positions:
                        if getattr(sell_pos, 'profit', 0) > 0:
                            sell_ticket = getattr(sell_pos, 'ticket', 'N/A')
                            if sell_ticket in used_positions:
                                continue
                            
                            used_positions.add(buy_ticket)
                            used_positions.add(sell_ticket)
                            break
            
            # ‡∏´‡∏≤ Sell ‡∏ï‡∏¥‡∏î‡∏•‡∏ö + Buy ‡∏Å‡∏≥‡πÑ‡∏£
            for sell_pos in sell_positions:
                if getattr(sell_pos, 'profit', 0) < 0:
                    sell_ticket = getattr(sell_pos, 'ticket', 'N/A')
                    if sell_ticket in used_positions:
                        continue
                    
                    for buy_pos in buy_positions:
                        if getattr(buy_pos, 'profit', 0) > 0:
                            buy_ticket = getattr(buy_pos, 'ticket', 'N/A')
                            if buy_ticket in used_positions:
                                continue
                            
                            used_positions.add(sell_ticket)
                            used_positions.add(buy_ticket)
                            break
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πâ‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô used_positions ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            pos_ticket = getattr(position, 'ticket', 'N/A')
            return pos_ticket in used_positions
            
        except Exception as e:
            logger.error(f"‚ùå Error checking hedge pair: {e}")
            return False
    
    def _get_combination_type(self, positions: List[Any]) -> str:
        """üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà"""
        try:
            sell_count = sum(1 for pos in positions if getattr(pos, 'type', 0) == 1)
            buy_count = sum(1 for pos in positions if getattr(pos, 'type', 0) == 0)
            
            if sell_count > buy_count:
                return f"SELL_MAJORITY_{sell_count}S+{buy_count}B"
            elif buy_count > sell_count:
                return f"BUY_MAJORITY_{buy_count}B+{sell_count}S"
            else:
                return f"BALANCED_{sell_count}S+{buy_count}B"
                
        except Exception as e:
            logger.error(f"‚ùå Error calculating combination type: {e}")
            return "UNKNOWN"
    
    def _calculate_confidence_score(self, positions: List[Any], total_profit: float) -> float:
        """üìà ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à"""
        try:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ï‡∏≤‡∏°‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏ï‡πà‡∏≤‡∏á‡πÜ
            profit_score = min(100, max(0, total_profit * 2))  # ‡∏Å‡∏≥‡πÑ‡∏£
            size_score = min(100, max(0, len(positions) * 10))  # ‡∏Ç‡∏ô‡∏≤‡∏î
            balance_score = self._calculate_balance_score(positions)  # ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏•
            
            # ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏£‡∏ß‡∏°
            total_score = (profit_score + size_score + balance_score) / 3
            
            return min(100, max(0, total_score))
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating confidence score: {e}")
            return 50.0
    
    def _calculate_balance_score(self, positions: List[Any]) -> float:
        """‚öñÔ∏è ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏•"""
        try:
            sell_count = sum(1 for pos in positions if getattr(pos, 'type', 0) == 1)
            buy_count = sum(1 for pos in positions if getattr(pos, 'type', 0) == 0)
            total_count = len(positions)
            
            if total_count == 0:
                return 0
            
            # ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡∏î‡∏∏‡∏• (‡∏¢‡∏¥‡πà‡∏á‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏¢‡∏¥‡πà‡∏á‡∏î‡∏µ)
            balance_ratio = min(sell_count, buy_count) / max(sell_count, buy_count)
            balance_score = balance_ratio * 100
            
            return balance_score
            
        except Exception as e:
            logger.error(f"‚ùå Error calculating balance score: {e}")
            return 50.0
    
    def _generate_additional_positions(self, positions: List[Any]) -> List[Any]:
        """üìà ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà"""
        try:
            additional_positions = []
            
            # ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
            unmatched_positions = self._find_unmatched_positions(positions)
            
            for pos in unmatched_positions[:self.max_additional_positions]:
                if getattr(pos, 'type', 0) == 1:  # Sell ‡∏ï‡∏¥‡∏î‡∏•‡∏ö
                    # ‡∏™‡∏£‡πâ‡∏≤‡∏á Buy ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
                    new_buy = self._create_opposite_position(pos, "BUY")
                    if new_buy:
                        additional_positions.append(new_buy)
                
                elif getattr(pos, 'type', 0) == 0:  # Buy ‡∏ï‡∏¥‡∏î‡∏•‡∏ö
                    # ‡∏™‡∏£‡πâ‡∏≤‡∏á Sell ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
                    new_sell = self._create_opposite_position(pos, "SELL")
                    if new_sell:
                        additional_positions.append(new_sell)
            
            logger.info(f"üìà Generated {len(additional_positions)} additional positions")
            return additional_positions
            
        except Exception as e:
            logger.error(f"‚ùå Error generating additional positions: {e}")
            return []
    
    def _find_unmatched_positions(self, positions: List[Any]) -> List[Any]:
        """üîç ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà"""
        try:
            unmatched_positions = []
            
            for pos in positions:
                profit = getattr(pos, 'profit', 0)
                
                # ‡πÑ‡∏°‡πâ‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
                if profit < 0:
                    unmatched_positions.append(pos)
            
            # ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô (‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô)
            unmatched_positions.sort(key=lambda x: getattr(x, 'profit', 0))
            
            logger.info(f"üîç Found {len(unmatched_positions)} unmatched positions")
            return unmatched_positions
            
        except Exception as e:
            logger.error(f"‚ùå Error finding unmatched positions: {e}")
            return []
    
    def _create_opposite_position(self, original_pos: Any, opposite_type: str) -> Optional[Any]:
        """üîÑ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏°‡πâ‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà"""
        try:
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà (‡∏à‡∏≥‡∏•‡∏≠‡∏á)
            new_pos = type('Position', (), {
                'ticket': f"NEW_{int(time.time())}",
                'symbol': getattr(original_pos, 'symbol', 'XAUUSD'),
                'type': 0 if opposite_type == "BUY" else 1,
                'volume': self.additional_position_volume,
                'price_open': getattr(original_pos, 'price_current', 0),
                'price_current': getattr(original_pos, 'price_current', 0),
                'profit': 0.0,  # ‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≥‡πÑ‡∏£
                'time': int(time.time()),
                'comment': f"Hedge for {getattr(original_pos, 'ticket', 'unknown')}"
            })()
            
            logger.info(f"üîÑ Created {opposite_type} position for ticket {getattr(original_pos, 'ticket', 'unknown')}")
            return new_pos
            
        except Exception as e:
            logger.error(f"‚ùå Error creating opposite position: {e}")
            return None

def create_hedge_pairing_closer() -> HedgePairingCloser:
    """‡∏™‡∏£‡πâ‡∏≤‡∏á Hedge Pairing Closer"""
    return HedgePairingCloser()
